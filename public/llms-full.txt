
# GitButler Documentation

## Table of Contents 

- [butler-flow](#butler-flow.mdx)
- [guide](#guide.mdx)
- [index](#index.mdx)
- [overview](#overview.mdx)
- [releases](#releases.mdx)
- [why-gitbutler](#why-gitbutler.mdx)
- [custom-csp](#custom-csp.mdx)
- [fetch-push](#fetch-push.mdx)
- [recovering-stuff](#recovering-stuff.mdx)
- [agents-tab](#agents-tab.mdx)
- [gerrit-mode](#gerrit-mode.mdx)
- [timeline](#timeline.mdx)
- [github-integration](#github-integration.mdx)
- [gitlab-integration](#gitlab-integration.mdx)
- [ai-assistance](#ai-assistance.mdx)
- [branch-lanes](#branch-lanes.mdx)
- [commits](#commits.mdx)
- [integration-branch](#integration-branch.mdx)
- [merging](#merging.mdx)
- [pushing-and-fetching](#pushing-and-fetching.mdx)
- [signing-commits](#signing-commits.mdx)
- [stacked-branches](#stacked-branches.mdx)
- [upstream-integration](#upstream-integration.mdx)
- [virtual-branches](#virtual-branches.mdx)
- [ai-overview](#ai-overview.mdx)
- [claude-code-hooks](#claude-code-hooks.mdx)
- [cursor-hooks](#cursor-hooks.mdx)
- [mcp-server](#mcp-server.mdx)
- [debugging](#debugging.mdx)
- [contact-us](#contact-us.mdx)
- [open-source](#open-source.mdx)
- [supporters](#supporters.mdx)
- [but-base](#but-base.mdx)
- [but-branch](#but-branch.mdx)
- [but-commit](#but-commit.mdx)
- [but-describe](#but-describe.mdx)
- [but-forge](#but-forge.mdx)
- [but-init](#but-init.mdx)
- [but-mark](#but-mark.mdx)
- [but-mcp](#but-mcp.mdx)
- [but-new](#but-new.mdx)
- [but-oplog](#but-oplog.mdx)
- [but-publish](#but-publish.mdx)
- [but-push](#but-push.mdx)
- [but-restore](#but-restore.mdx)
- [but-rub](#but-rub.mdx)
- [but-snapshot](#but-snapshot.mdx)
- [but-status](#but-status.mdx)
- [but-undo](#but-undo.mdx)
- [but-unmark](#but-unmark.mdx)
- [installation](#installation.mdx)
- [branching-and-commiting](#branching-and-commiting.mdx)
- [editing-commits](#editing-commits.mdx)
- [initializing-a-repository](#initializing-a-repository.mdx)
- [operations-log](#operations-log.mdx)
- [rubbing](#rubbing.mdx)
- [scripting](#scripting.mdx)
- [tutorial-overview](#tutorial-overview.mdx)
- [updating-the-base](#updating-the-base.mdx)


# butler-flow.mdx

Butler Flow is a lightweight, branch-based workflow enabled by GitButler virtual branch functionality.

Most modern software development teams today that want to set up a culture of shipping, who push to production every day, who are constantly testing and deploying, one of the most popular and effective development workflows is [GitHub Flow](https://docs.github.com/en/get-started/quickstart/github-flow).

These are wise words, enterprising men quote 'em. Don't act surprised, you guys, [cuz I wrote 'em](https://scottchacon.com/2011/08/31/github-flow).

However, a decade later, and with a new and more powerful branching toolset, we're able to amend that basic workflow to be simpler, faster, more flexible and less error prone. Let's take a quick minute to explore what the Butler Flow is for software development teams using GitButler and how this can make all of our lives easier.

## Overview

- In a nutshell, the basic development cycle is very simple.
- All work is based off a "target branch", which is a representation of released production code.
- All work immediately exists in a branch.
- Work can be shared with teammates for review as early as possible.
- All branches that are close to merging can be applied locally for integration testing.
- Branches can be reviewed independently and merged after final review.
- Integrated branches are automatically removed from developer context.

### The Target Branch

In stock Git tooling, there is nothing specified as the production branch, no special "trunk". It is only by convention that this is enforced.

In GitButler, virtual branches will not work without the specification of a special "target branch". Everything exists in relation to this special branch, everything that differs from it must be accounted for by being owned by some other branch, until those changes are integrated.

### Virtual Branches

Once you choose a target branch, everything that is in your working directory and not ignored by the Git ignore specification must be owned by a virtual branch. If you don't have one active, GitButler will automatically create one for you.

All subsequent changes to your working directory, either by applying other branches or directly modifying files, must be owned by a virtual branch.

Branches are meant to be small, independent and rapidly integrated. However, longer lived branches can be continuously re-integrated, keeping them clean and mergeable for long periods of time if needed, while still being shareable and reviewable with your team.

Virtual branches can be started and ended entirely independently of each other. Developers can work on longer branches, while starting, reviewing, finishing, merging and deleting small ones without ever changing branch context.

### Collaboration

All coworkers' work, whether created and managed by GitButler or not, exists on the central server as normal Git branches. These will automatically be pulled down and kept up to date by GitButler and can be converted into virtual branches and applied to your working directory in addition to your branches.

This allows you to integrate work from the rest of your team continuously and early, while still keeping non-dependent changes separated and independently reviewable and mergable. It allows you to review code without needing to entirely switch contexts, and to do so early and often in an executable environment.

Merge conflicts are known almost as soon as they occur and can be communicated about and collaborated on far before an upstream merge.

### Maintenance

Virtual branches can remain applied locally until they are merged into your upstream target branch. Once integrated by any fashion (squash merge, rebase, merge), the virtual branch is automatically disposed of, keeping cruft and overhead low.


# guide.mdx

Here is a quick overview of how to get started with GitButler. In this guide, we will:

- Get setup and start working with a local repository
- Do work and commit on several branches simultaneously
- Push your work to a remote repository and get it integrated
- Reorder and edit your commits
- Undo anything

## Importing a Local Repository

After [downloading](https://app.gitbutler.com/downloads) and installing GitButler, you will be greeted with the welcome screen. From here you can 
<ImageSection
  alt="Import screen"
  src="/started/welcome-screen.png"
  subtitle="First thing you see when you launch GitButler"
/>

Let's start by importing an existing Git project on your disk. If you click "Add local project" and then choose the directory of the existing Git initialized project, then we will start the 
## Choosing a Target Branch

<ImageSection
  alt="Import screen"
  src="/started/import.png"
  subtitle="First step: choose your target branch"
/>

The first step is to choose your "target" branch. GitButler focuses on a trunk based development model, so first you need to tell us what branch means "production" to you. Normally this is something like `origin/master` or `origin/main`.

If you would like to use our AI features like commit message generation, you can also sign up for a GitButler account and log in. This is optional, but we'll do it here so we can show off these features.

You can also connect GitButler to your GitHub account so we can automatically open Pull Requests for you, but this is also optional.

## Set Up Git Authentication

In order to push to a remote repository, you will need to set up your Git authentication. We provide three ways to do this, but generally it's easiest to use the existing Git executable. You can hit the "Test credentials" button to make sure everything is working properly.

<ImageSection
  alt="Git configuration screen"
  src="/started/setup-git.png"
  subtitle="Second step: configure your git pushes"
/>

## Ready to Go

Ok, now we're all setup and you should see our main working screen. If you had a branch with some work in progress, you should see it imported already. Otherwise, you will see a blank workspace with no branches applied.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/initial-space.png"
  width="800"
  height="600"
  subtitle="A workspace with no initial branches"
/>

## Do Some Work

Now we can start working. GitButler will watch your working directory and immediately show any changes that you make.

In the above case, we can see that there are some changes to the `README.md` file. Let's create a new branch and commit our changes to it. You can click the "Create Branch" button in the workspace, or the "Commit to new branch" button below the Unassigned changes.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/CleanShot%202025-07-02%20at%2010.44.12%402x.png"
  width="800"
  height="600"
  subtitle="Creating a new branch."
/>

You can click on any file to see what the diff is.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/view-file.png"
  width="800"
  height="600"
  subtitle="view-file.png"
/>

Now that you have a branch, you can simply hit the "Start a Commit" button on the branch you want to commit to, then either write your commit message, or hit "Generate Message" to let AI look at the diffs and write a message for you.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/CleanShot%202025-07-02%20at%2010.53.15%402x.png"
  width="800"
  height="600"
  subtitle="Simple commit message dialog"
/>

Once you've done that, you should see something like this:

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/post-commit.png"
  width="800"
  height="600"
  subtitle="Now we can see our one commit on our branch"
/>

## Split secondary work into a new branch

Now let's say that I decide to add a new feature and don't want it to depend on my README change. Instead of stashing my changes and doing that, or committing unrelated work into the branch I'm on, I can simply create a new parallel branch, drag my work over there and commit there.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/two-branches.png"
  width="800"
  height="600"
  subtitle="Now we have two branches, both applied"
/>

Now both branches are applied, but I can commit to them independently and push them to a remote repository at different times.

## Integrate Your Work

Since the README updating branch is ready to be merged, I can push that branch up, open a Pull Request on it and wait for it to be integrated, while I continue to work on and commit to my other feature branch.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/integrated2.png"
  width="800"
  height="600"
  subtitle="One branch is pushed and we can see that it has been integrated upstream."
/>

Now we have a series of commits on our feature branch, which we've continued to work on while we're waiting for our README update to be integrated.

GitButler sees that our target branch has new work and shows us the "Update" button, which we can click to rebase our feature branch on top of the new work and also remove the README branch automatically, since we can see that it has been integrated upstream.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/update-base.png"
  width="800"
  height="600"
  subtitle="Updating from upstream will automatically remove integrated branches and rebase other branches on top of the new work."
/>

## Reorder and Edit Your Commits

GitButler makes it very easy to edit, reorder, squash and split commits. If you hover over any commit, you will see a drag handle on the top right. You can drag the commit to reorder it, or drag it on top of another commit to squash them together.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/move-commit.png"
  width="800"
  height="600"
  subtitle="Drag one commit on top of another to squash, above or below to reorder, or to another branch to move it."
/>

To split a commit, you can insert an "empty" commit in between the two commits you want to split, then drag the changes from the commit you want to split into the empty commit.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/add-empty-commit.png"
  width="800"
  height="600"
  subtitle="Add a new empty commit above or below an existing one"
/>

Now you can drag the changes from the commit you want to split into the new empty commit.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/amend-to-empty-commit.png"
  width="800"
  height="600"
  subtitle="Drag files from one commit to another, in this case, amending the previously empty commit"
/>

Finally, you can edit the commit message of the previously empty commit to give it a meaningful message, and now you have split the original commit into two separate commits.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/add-commit-message.png"
  width="800"
  height="600"
  subtitle="add-commit-message.png"
/>

You can also uncommit any commit without dependencies, or even individual files in a commit.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/uncommit.png"
  width="800"
  height="600"
  subtitle="Uncommit any commit"
/>

All of this makes it very easy to build up and maintain a nice, clean history that is easy to understand and work with.

## Unapply a stack

If you decide that you don't want to work on a branch anymore, you can simply unapply it. This will remove all the changes from that branch from your working directory, but keep the branch around in case you want to reapply it later.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/unapply-stack.png"
  width="800"
  height="600"
  subtitle="Unapply a branch to remove those changes from your working directory and save the work"
/>

## Undo Anything

If at any time, you do something that you didn't mean to do, you can always undo it. You can undo a commit, a commit edit, a squash, an upstream update, a branch application, anything.

Just click the "Operations History" button in the sidebar, find the action you want to rewind to and hit the "Revert" button.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/ophistory.png"
  width="800"
  height="600"
  subtitle="Revert back to a previous point in time with the Operations History"
/>


# overview.mdx


# Butler Review

<Callout type="warn">
  We have paused work on Butler Review for now to concentrate more on the client experience. Review
  will be coming back in our upcoming server functionality, stay tuned.
</Callout>

Butler Review is a new approach to code review that focuses on reviewing code
as a series of evolving patches rather than a unified diff of a whole branch.

<ImageSection
  alt="Butler Review"
  src="/review/branch.png"
  subtitle="A patch series in Butler Review"
/>

## Why Butler Review?

Traditional code review tools like GitHub and GitLab show changes as a single
diff of the entire branch. This makes it hard to review changes in a branch
incrementally, especially when the branch is large. It also discourages creating
good commit or commit messages, since they are all sqaushed in review and
messages are difficult to find and unrelated to the code review UI.

Butler Review approaches the problem differently, by making it easy to review
individual commits as patches and tracking changes to the series when you rebase
or amend the branch.

This makes it easier to review changes incrementally and evolve a series rather
than pushing poor commits to the branch to address feedback.

## Enabling Butler Review

To start using Butler Reviews, you need to enable the feature in your GitButler
client in the project settings. Click the gear icon in the bottom left corner of
the GitButler client and go to the Server tab.

<ImageSection alt="Review Setting" src="/review/settings.png" subtitle="Turning on Butler Review" />

Once you enable Butler Review, you can start creating reviews for your branches.

## Creating a Review

Once you have enabled Butler Review for a project, you can create a review for
a branch by clicking the new "Create Butler Review" button in the branch header card.

<ImageSection
  alt="Create Review"
  src="/review/create-review.png"
  subtitle="Creating a Butler Review"
/>

Once you create a review, you will see a new card in the branch header that
shows the status of the review.

<ImageSection
  alt="Butler Review Card"
  src="/review/review-card.png"
  subtitle="Butler Review Card"
/>

If you have GitHub integration enabled, you will see a dropdown to let you choose
to create a PR or a Butler Review. You can also create both, in either order and
they will be linked together.

<ImageSection
  alt="Butler Review Card"
  src="/review/review-card-both.png"
  subtitle="Branch header card with both PR and BR status"
/>

Once a Review has been opened, you will have a URL that you can share with your
team to get feedback on your changes.

## Reviewing a Series

When a reviewer opens a review, they will see a list of patches that make up the branch.

<ImageSection
  alt="Butler Review"
  src="/review/branch.png"
  subtitle="A patch series in Butler Review"
/>

<Callout type="warn">
  Currently, all reviews are "unlisted", meaning that anyone with the URL can see the review.
  In the future, we will implement fully public and fully private reviews, but currently all reviews
  are unlisted.

However, if someone has the URL, they will only be able to see the patch data,
they will not have access to all of your source code, nor will they be able to make changes,
only approve or request changes.

</Callout>

Now the reviewer can hit "Start Review" to start reviewing the patches in the series.
It will start them at the "bottom", the first patch and they can work their way up.
The reviewer can also click on a patch to go directly to it.

## Reviewing a Patch

Once a reviewer starts reviewing a patch, they will see the changes in the commit
and a chat window to leave comments.

<ImageSection alt="Reviewing a Patch" src="/review/patch2.png" subtitle="Reviewing a Patch" />

The reviewer can leave comments on the patch, approve the patch, or request changes.
The chat discussion is real time, so reviewers can discuss the changes with the author
as they review the patch.

You can also select lines of code to comment on. This will highlight the line in the
diff and show the comment in the chat window.

Every patch needs to be approved before the branch is considered approved.

## Requesting Changes

A reviewer can either approve a patch or request changes. If they request changes,
the author can amend that specific commit and publish the changes to the review.

Reviewers will be able to see in the chat that a new version of the patch has been
published and they can review the changes again.

<Callout>
  Currently we don't have interdiffs, so reviewers will need to review the entire patch again. We
  plan to add interdiffs in the very near future.
</Callout>

## Approving a Patch

Once a reviewer is happy with a patch, they can approve it. This will mark the patch
as approved and move the reviewer to the next patch in the series.

## Closing a Review

Once the branch has been merged, it will automatically mark the review as closed.
The author can also manually close the review if they decide to abandon the series.


# why-gitbutler.mdx

The GitButler manifesto, as it were.

Everyone loves a good manifesto. So, why is there a need for a new Git client in the world? Don't we have enough? Isn't the command line just fine?

Having cofounded GitHub, trained dozens of corporate teams on distributed version control tools and literally written the book on Git, we have spent a lot of time and energy over the last decade thinking about the source code management tools that software developers use every day.

GitHub has changed the way that millions of developers across the world collaborate and work with their source code, but as sophisticated and user friendly as that tool is in our daily coding lives, using GitHub or GitLab or Bitbucket still requires all of those developers to work with a command line tool that is confusing, difficult to use, error prone and not originally designed or built for the workflows and processes that most developers today use. That tool is Git.

Sure, some small minority will use a GUI of some sort, but even those tools are mostly wrappers around the core concepts of Git itself, never reimagining what source code management could be or if Git itself is actually good at helping them with the tasks they face on a daily basis. I've never personally used one because they do little that Git itself doesn't and honestly it's generally easier to just do those tasks on the command line, where it's quick and efficient and I don't have to take my hands off the keyboard.

But what if we broke down everything that you try to accomplish with Git, with source code management tools in general, reduce them down to first principles and imagine a tool that does all of those things better? Are you using Git because it's the best way you can imagine accomplishing those tasks, or are you using it because it's what is there, it's what works with GitHub, it's the only real option?

The reality is that source code management tools have changed very little on a fundamental level in the last 40 years. If you look at the tools and commands and interface that RCS had in the 80s, or Subversion had in the 90s, is it really massively different than how you use Git today on a daily basis?

Yes, Git has easy branching, acceptable merging, a nice network transport method to move your code around, but you're still making manual checkins, you're still trying to remember obscure arguments, you're still losing work when things get complicated.

GitButler is rethinking everything between when you write code in your editor of choice and when you push that code to GitHub for review. Why are you making 'wip' commits when your SCM should be recording everything for you? Why are everyone's commit messages close to useless? Why is `git blame` the best way to get context on the code your team has written? Why can't you seamlessly transition work between computers?

We are creating not only a new kind of Git client, but an entirely new way of thinking about managing the code that you work on. A tool that helps you at every step of the software development process. A code concierge, hard at work for you to ensure that you'll never lose a moment of work again. That you'll have all the context and support you'll need around every line of code you work on.

Managing your source code can be different, smarter, leaps ahead of the 40 year old concepts that we're using today.

Our goal is to make sure that nobody ever has to read Scott's book again. That you don't have to learn how to manage your source code management tool.

<img src="/img/markus-chill.svg" className="mx-auto" />


# releases.mdx


GitButler is released on a regular basis in two separate tracks. Their version numbers are incremented independently.

1. **Release** - stable releases
2. **Nightly** - development releases built at minimum 1x per day via GitHub Actions.


<Callout type="info">
You can find the download links and changelogs for the latest releases on our [GitHub Releases](https://github.com/gitbutlerapp/gitbutler/releases).
</Callout>

## Platforms

We bundle and ship GitButler for Mac OS, Windows, and Linux.

### Windows

| Arch | Format | In-app updater |
| --- | --- | --- |
| `x86_64` | `msi` | <svg width="20" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><rect width="256" height="256" fill="none"/><polyline points="88 136 112 160 168 104" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/><circle cx="128" cy="128" r="96" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/></svg> |

### Mac OS

| Arch | Format | In-app updater |
| --- | --- | --- |
| `x86_64` | `dmg` | <svg width="20" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><rect width="256" height="256" fill="none"/><polyline points="88 136 112 160 168 104" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/><circle cx="128" cy="128" r="96" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/></svg> |
| `arm64` | `dmg` | <svg width="20" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><rect width="256" height="256" fill="none"/><polyline points="88 136 112 160 168 104" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/><circle cx="128" cy="128" r="96" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/></svg> |

### Linux

| Arch | Format | In-app updater |
| --- | --- | --- |
| `x86_64` | `deb` | <svg width="20" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><rect width="256" height="256" fill="none"/><polyline points="88 136 112 160 168 104" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/><circle cx="128" cy="128" r="96" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/></svg> |
| `x86_64` | `rpm` | <svg width="20" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><rect width="256" height="256" fill="none"/><polyline points="88 136 112 160 168 104" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/><circle cx="128" cy="128" r="96" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/></svg> |
| `x86_64` | `AppImage` | <svg width="20" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><rect width="256" height="256" fill="none"/><line x1="160" y1="96" x2="96" y2="160" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/><line x1="96" y1="96" x2="160" y2="160" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/><circle cx="128" cy="128" r="96" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/></svg> |

> Support for the Linux releases are complicated a bit through a core dependency of our framework, `libwebkit2gtk`, which is used to provide the web view on Linux. Tauri v1 required `libwebkit2gtk-4.0` which is not available in Ubuntu 24.04 or Debian 13 and newer.
>
> We've recently upgraded to Tauri v2 (as of Nightly `0.5.845` and Release `0.13.9`), and it now requires `libwebkit2gtk-4.1`. This version of the package is not available in the repositories for Ubuntu 20.04 and older as well as Debian 11 and older.
>
> For more information, check out the [pinned issue](https://github.com/tauri-apps/tauri/issues/9662) in the Tauri repository.


# fetch-push.mdx


If you are having trouble pushing or fetching from a remote, this is likely related to git authentication. Here are a few configuration options you can try out, found in the project settings.

## Configuring the auto-fetch frequency

GitButler will periodically fetch from your configured remotes in order to display new branches etc. By default, this happens every every 15 minutes.

You can configure the interval or completely disable this behavior by editing the application's `settings.json` file:

<Tabs groupId="platform" items={["macOS", "Windows", "Linux"]} persist>
  <Tab value="macOS">```bash ~/Library/Application\ Support/gitbutler/settings.json ```</Tab>
  <Tab value="Windows">```bash C:\Users\[username]\AppData\Roaming\gitbutler\settings.json ```</Tab>
  <Tab value="Linux">```bash ~/.config/gitbutler/settings.json ```</Tab>
</Tabs>

The file is in JSONC format and follows the [following schema](https://github.com/gitbutlerapp/gitbutler/blob/master/crates/but-settings/assets/defaults.jsonc)

```json
  "fetch": {
    "autoFetchIntervalMinutes": 15
  }
```

A negative value (e.g. -1) disables auto fetching. Note that if `fetch` is the only entry in the JSON file, you may want to enclose it in a top-level object.

## Available authentication methods

GitButler can be configured to use several different git authentication methods. You can switch between them in your project settings. You can try multiple different options and see if any of them are appropriate for your setup. Note that if you are on Windows, the only applicable method is the "Git executable", therefore the application will now show this as a configuration option. 

<ImageSection
  alt="Virtual Branches Example"
  src="/issues-01.png"
/>

### Use a Git executable (default)

The default way to push and fetch is for GitButler to use an existing system Git executable. This should use whatever authentication mechanism that Git uses for the remote that you're trying to push to or fetch from.

### Use an existing SSH key

If already have an SSH key set up (eg. `~/.ssh/id_rsa`), you can instruct GitButler to use it. In case the key is password protected, you can also provide the password to it (which will be stored locally).

### Use locally generated SSH key

This option generates a new SSH key which will be stored locally in the application [data dir](https://docs.gitbutler.com/development/debugging#data-files). For this to work you will need to add the new public key to your Git remote provider.

### Use a git credential helper

If your system is set up with a credential helper, GitButler can use that. For more info on git credential helpers, see this [article](https://git-scm.com/doc/credential-helpers).

### FIDO security keys (YubiKey, etc.)

If you're using a FIDO key, check out this issue to see how people have set it up with the Git executable method: [#2661](https://github.com/gitbutlerapp/gitbutler/issues/2661)

### Keys managed by 1Password

Keys stored in 1Password should properly use it as an SSH agent for authentication and signing commits if you use the Git executable option. (Previously tracked in [#2779](https://github.com/gitbutlerapp/gitbutler/issues/2779))

### Host certificate checks

There is an option to ignore host certificate checks when authenticating with ssh. This may be a helpful option to enable in some cases.

## Other known issues

### Git remote servers with a non-standard SSH port
In some cases, the git remote may be setup on a port number other than 22. If the port is set in your `~/.ssh/config` file, GitButler will not be able to recognize that - tracked in GitHub issue [#2700](https://github.com/gitbutlerapp/gitbutler/issues/2700).

As a workaround you may set your remote in the [SSH format](https://git-scm.com/book/en/v2/Git-on-the-Server-The-Protocols) (eg. `ssh://git@example.com:3022/foo/bar.git`)

Updating virtual branches when the respective remote has new commits
If you have added a remote branch to your active workspace in GitButler, or pushed a virtual branch to the remote, and new commits are added to the remote branch, there is currently no way to sync those new commits into the existing virtual branch in GitButler. This is being tracked in the GitHub issue [#2649](https://github.com/gitbutlerapp/gitbutler/issues/2649).

The current workaround is to undo any local commits and then stash your local changes manually using [git stash](https://git-scm.com/docs/git-stash) and then delete the virtual branch that has upstream changes. Then you can update the trunk by clicking the update button next to the word "Trunk" in the sidebar on the left to make sure all new upstream changes are synced, then select the remote branch that has the new changes and click the "Apply +" button above the list of commits for the branch. Once the updated branch is applied to your working directory, you can manually `git stash pop` your stashed changes and then resolve any merge conflicts.

### OAuth app access restrictions on your GitHub organization

If you're submitting code and PRs to a repository under an organization on GitHub, you may receive an error that, despite having correct authorization credentials, your organization has enabled OAuth app access restrictions. These restrictions are an organization-level security feature designed to prevent unauthorized third-party applications from accessing organization resources.

To solve this, go to Applications. Select the "Authorized OAuth Apps" tab, and look for "GitButler Client". If you don't find "GitButler Client", it's possible you haven't yet set GitButler up for personal use. If so, try creating a test commit on a test branch for a personal repository using GitButler, which you can delete after, then check the same tab as before.

If you see "GitButler Client", click on it and, under "Organization Access", across from the organization you wish to enable GitButler for, click either the "Request" or "Grant" button, depending on whether you are a contributor or owner, respectively. If you're a contributor clicking "Request", note that you'll need to wait for an organization owner to approve your access request before you can proceed.

Note for organization owners: To streamline this process for your team members, you can pre-approve GitButler for all organization members. This eliminates the need for individual access requests and approvals. This can be managed through your organization's OAuth app access settings.

### Help on Discord
If none of the available options helps, feel free to hop on our [Discord](https://discord.gg/MmFkmaJ42D) and we will be happy to help you out.



# custom-csp.mdx


By default GitButler uses a strict Content Security Policy (CSP) to protect against various attacks, such as cross-site scripting (XSS) and data injection attacks. This policy restricts the sources from which content can be loaded, as well as the hosts the application can connect to, ensuring that only trusted sources are allowed.

However, there are some cases where you may need to customize the CSP to allow certain features or integrations. Some examples include:
- Self-hosted GitHub Enterprise instances
- Self-hosted GitLab instances
- Self-hosted Ollama instances

In those cases you are likely to observe an error message that looks something like this:

```
Refused to connect to https://<YOURDOMAIN>.<TLD>/api/v4/projects/9/merge_requests because it does not appear in the connect-src directive of the Content Security Policy.
```

You can resolve this issue by adding your host to the CSP. 

## Adding a Custom CSP

You can add a custom CSP by editing the GitButler configuration file, found at the following location:

<Tabs groupId="platform" items={['macOS', 'Windows', 'Linux']} persist>
  <Tab value="macOS">
  ```bash
  ~/Library/Application\ Support/gitbutler/settings.json
  ```
  </Tab>
  <Tab value="Windows">
  ```bash
  C:\Users\[username]\AppData\Roaming\gitbutler\settings.json
  ```
  </Tab>
  <Tab value="Linux">
  ```bash
  ~/.config/gitbutler/settings.json
  ```
  </Tab>
</Tabs>

The file is in JSONC format and follows the [following schema](https://github.com/gitbutlerapp/gitbutler/blob/master/crates/but-settings/assets/defaults.jsonc)

In order to add your custom CSP entry, you want to add an `extraCsp` entry to the JSON file. The `extraCsp` entry is an object that contains a `hosts` array, which is where you can add your custom hosts. For example:

```json
"extraCsp": {
  "hosts": ["https://subdomain.example.com", "http://another-subdomain.example.com"]
}
```

Note that if `extraCsp` is the only entry in the JSON file, you may want to enclose it in a top-level object, like this:

```json
{
  "extraCsp": {
    "hosts": ["https://subdomain.example.com", "http://another-subdomain.example.com"]
  }
}
```

The changes will take effect the next time you start GitButler.

# recovering-stuff.mdx


How to dig around our internal data to find (nearly) anything

GitButler saves data in a few different ways. As we're still in beta, sometimes things might break and it may look like you've lost work, but you almost certainly haven't. We're pretty good about saving stuff a lot. Here's how to recover almost anything you had in your working directory or virtual branches.

## GitButler References

If everything crashes or the UI isn't working at all, you may be surprised to know that even though your virtual branches don't show up in a normal git branch output, we do actually constantly write them out as Git references (just not in refs/heads).


```bash title="Terminal"
❯ git for-each-ref | grep gitbutler
e63b3bac82835dc17083a785d25db8b4b46744b9 commit	refs/gitbutler/add-can-create-method-to-notebook
98ef3cd6eea14ee4159a600e448271c0d777efe2 commit	refs/gitbutler/add-conditional-blocks-for-image-and-video
c7e27b9f99f25160a4d5f07d5972c217bdd44319 commit	refs/gitbutler/add-database-schema-conversion-script
4afdfed6c14b57491a9d295c31613fd79b92f63a commit	refs/gitbutler/add-gems-for-test-group
```


These references are just like git branches - they point to a commit that has the latest version of your branch. You can create other git branches off of them, you can push them to GitHub, etc.

You will have one for each virtual branch (applied or unapplied) that you've created (that you haven't deleted).

If you've committed everything on a virtual branch, the reference will just point to the latest commit. If you have work in progress on the branch, it will point to a WIP commit that includes those changes.

So for example, if I have the following two virtual branches, one fully committed and one with work pending:

<ImageSection
  alt="Virtual Branches Example"
  src="/recovering-01.webp"
/>


I can view the git branches like this:

```bash title="Terminal"
❯ git show gitbutler/Convert-tables-to-utf8mb4
commit 841e4db701ca41206c03f1f4fe345f7e27d05eab
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Feb 23 10:30:17 2024 +0100

    my latest commit

❯ git show gitbutler/Add-database-schema-conversion-script
commit d95e7f4da1611ea6bb8a80da06e66ca923fbff55
Author: GitButler <gitbutler@gitbutler.com>
Date:   Fri Feb 23 10:30:18 2024 +0100

    GitButler WIP Commit

    This is a WIP commit for the virtual branch 'Add database schema conversion script'

    This commit is used to store the state of the virtual branch
    while you are working on it. It is not meant to be used for
    anything else.
```

See how the `Add-database-schema-conversion-script` reference points to a "WIP commit"? The tree of that commit has all those changed files in it as though we had committed them.

If you don't want to search through all your refs with `for-each-refs`, you can also just run a normal `git log` command and we'll show you what references we've written and which modified files are in each one:

```bash title="Terminal"
❯ git log
commit 2d8afe0ea811b5f24b9a6f84f6d024bb323a2db5 (HEAD -> gitbutler/workspace)
Author: GitButler <gitbutler@gitbutler.com>
Date:   Fri Feb 23 10:30:18 2024 +0100

    GitButler Integration Commit

    This is an integration commit for the virtual branches that GitButler is tracking.

    Due to GitButler managing multiple virtual branches, you cannot switch back and
    forth between git branches and virtual branches easily.

    If you switch to another branch, GitButler will need to be reinitialized.
    If you commit on this branch, GitButler will throw it away.

    Here are the branches that are currently applied:
     - Add database schema conversion script (refs/gitbutler/Add-database-schema-conversion-script)
       - butler/Gemfile
       - butler/README.md
       - butler/db/schema.rb
       - butler/db/migrate/20240209144600_change_mysql_charset.rb
       - .pscale.yml
     - Convert tables to utf8mb4 (refs/gitbutler/Convert-tables-to-utf8mb4)
       branch head: 841e4db701ca41206c03f1f4fe345f7e27d05eab
       - butler/create_column_conversions.rb

    Your previous branch was: refs/heads/sc-branch-comments

    The sha for that commit was: 5e16e99667db9d26f78110df807853a896120ff3

    For more information about what we're doing here, check out our docs:
    https://docs.gitbutler.com/features/branch-management/integration-branch
```

You can see the two `gitbutler` refs under the "Here are the branches that are currently applied" section.

Again, these are real git refs, just not under `refs/heads` so that we don't pollute your `git branch` output. But if GitButler crashes at some point, you can still push them to GitHub or whatever you want. Here is an example pushing my virtual branch to a GitHub branch called `convert-tables`:

```bash title="Terminal"
❯ git push origin refs/gitbutler/Convert-tables-to-utf8mb4:refs/heads/convert-tables
Enumerating objects: 6, done.
Counting objects: 100% (6/6), done.
Delta compression using up to 10 threads
Compressing objects: 100% (4/4), done.
Writing objects: 100% (4/4), 474 bytes | 474.00 KiB/s, done.
Total 4 (delta 2), reused 1 (delta 0), pack-reused 0
remote: Resolving deltas: 100% (2/2), completed with 2 local objects.
remote:
remote: Create a pull request for 'convert-tables' on GitHub by visiting:
remote:      https://github.com/gitbutlerapp/web/pull/new/convert-tables
remote:
To github.com:gitbutlerapp/web.git
 * [new branch]        refs/gitbutler/Convert-tables-to-utf8mb4 -> convert-tables
```

## GitButler Operations Log

Ok, let's say that your work was not in one of those refs for some reason. Maybe you hit some weird bug and it completely changed everything in a way where now you're sitting on the couch in the dark with a glass of whisky, slowly mumbling the word "GitButler..." and plotting your revenge.

Most of the time, we'll have whatever you're looking for in our operations log.

The easiest way to access this is to use the built in Project History UI: [Project History](/features/timeline)

However, let's dig into how this works, just in case you want to check it out yourself.

Every time that GitButler does some possibly data-changing operation, we store a snapshot of your project state in our operations log before the operation happens so you can undo it if you want to. This is stored as a Git commit history that is parallel to your projects (ie, no common parents).

You can inspect this by looking at the `.git/gitbutler/operations-log.toml` file.

```bash title="Terminal"
❯ tree .git/gitbutler
.git/gitbutler
├── operations-log.toml
└── virtual_branches.toml

1 directory, 2 files

❯ cat .git/gitbutler/operations-log.toml
head_sha = "16e47cb1d091ca9dd44327fef2f5305b09403a95"

[modified_at]
secs_since_epoch = 1717663406
nanos_since_epoch = 560458000
```

If we look at this commit, we can see the history of all of the project history snapshots that GitButler is keeping:

```bash title="Terminal"
❯ git log 16e47cb1d091ca9dd44327fef2f5305b09403a9 -2
commit 16e47cb1d091ca9dd44327fef2f5305b09403a95
Author: GitButler <gitbutler@gitbutler.com>
Date:   Thu Jun 6 10:43:26 2024 +0200

    CreateBranch

    Version: 1
    Operation: CreateBranch
    name: Virtual branch

commit 2c95aa06d76b3230f1a51d9f89a211770d93ae51
Author: GitButler <gitbutler@gitbutler.com>
Date:   Thu Jun 6 10:28:30 2024 +0200

    UpdateWorkspaceBase

    Version: 1
    Operation: UpdateWorkspaceBase
```

You can see that before creating a branch or updating our workspace with upstream work, we're recording the state of our project so we have an undo point. So what data are we keeping here in addition to this trailer information?

Let's look at the tree of one of these commits:

```bash title="Terminal"
❯ git cat-file -p 16e47cb1d091ca9dd44327fef2f5305b09403a95^{tree}
040000 tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904    conflicts
040000 tree b283f22f5abf4ed9c612c1b5b3b9a98ec25474b0    index
040000 tree b283f22f5abf4ed9c612c1b5b3b9a98ec25474b0    target_tree
100644 blob d839dca7e14f5833ad737b4adbf337bd20489927    virtual_branches.toml
040000 tree a0821552c0e7d5defe369d577af5e3a87b442469    virtual_branches
```

The virtual branches toml file has the interesting metadata:

```bash title="Terminal"
❯ git cat-file -p 16e47cb1d091ca9dd44^{tree}:virtual_branches.toml
[default_target]
branchName = "master"
remoteName = "origin"
remoteUrl = "git@github.com:gitbutlerapp/gitbutler.git"
sha = "e00e54af7f903ef84600079a45490a7f07e4702e"
pushRemoteName = "origin"

[branch_targets]

[branches.09ef54c4-1081-4a52-8182-a5ec725016b6]
id = "09ef54c4-1081-4a52-8182-a5ec725016b6"
name = "commit signing settings"
notes = ""
applied = false
upstream = "refs/remotes/origin/commit-signing-settings"
upstream_head = "b60a66452dfecef74103346af6a3291ad677d246"
created_timestamp_ms = "1717489406268"
updated_timestamp_ms = "1717489406268"
tree = "b28e7eefdd7b6f36456516b696146a2ea7638ca4"
head = "b60a66452dfecef74103346af6a3291ad677d246"
ownership = ""
order = 4
selected_for_changes = 1717489406268
```

The virtual_branches tree has the actual contents of those computed branches in case we need to recreate them:

<Files>
  <Folder name="virtual_branches" defaultOpen>
    <Folder name="[branch-id]" defaultOpen>
      <Folder name="commits" defaultOpen>
        <Folder name="[commit-id1]" defaultOpen>
            <File name="commit" />
            <File name="tree" />
        </Folder>
        <File name="[commit-id2]" />
      </Folder>
      <File name="tree" />
    </Folder>
    <Folder name="[branch-id]" defaultOpen>
      <Folder name="commits">
        <File name="[commit-id3]" />
        <File name="[commit-id4]" />
      </Folder>
      <File name="tree" />
    </Folder>
  </Folder>
</Files>

This allows you to get contents of any file in any of your virtual branch states as well.


# agents-tab.mdx


GitButler can also orchestrate your coding agents and help automatically manage, checkpoint and commit the work that they do for you.

<Callout type="info">
  Currently the only supported agent is [Claude Code](https://www.anthropic.com/claude-code), but we
  are working on more agent support.
</Callout>

You can access our agent management in the Agents Tab:

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/CleanShot%202025-09-04%20at%2015.37.39%402x.png"
  width="800"
  height="600"
  subtitle="GitButler Agents Tab"
/>

The agents tab can run multiple Claude Code agents at the same time and will automatically try to assign file edits done by each to a specific branch. So each branch is essentially a context that an agent can directly work on.

# Setup

There is some basic setup that may need to be done the first time, if you've never used Claude Code before.

### Installing Claude Code

Before you can use the agents tab, you need to have Claude Code installed as we wrap the SDK that it provides. If we can't find the binary, you should see something like this:

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/CleanShot%202025-09-05%20at%2014.37.45%402x.png"
  width="800"
  height="600"
  subtitle="Wherefor art thou, Claudius?"
/>

To install Claude Code, you can read through the docs [here](https://docs.anthropic.com/en/docs/claude-code/quickstart), but the simple version is to use their "Native Install" method:

{/* <!-- prettier-ignore-start --> */}

<Tabs groupId="platform" items={["macOS and Linux", "Windows PowerShell", "Windows CMD"]} persist>
  <Tab value="macOS and Linux">
    ```bash
    curl -fsSL https://claude.ai/install.sh | bash
    ```
  </Tab>
  <Tab value="Windows PowerShell">
  ```bash
  irm https://claude.ai/install.ps1 | iex
  ```
  </Tab>
  <Tab value="Windows CMD">
    ```bash
    curl -fsSL https://claude.ai/install.cmd -o install.cmd && install.cmd && del
    install.cmd
    ```
  </Tab>
</Tabs>
{/* <!-- prettier-ignore-end --> */}

You will then need to setup and login to Claude Code, which will require an Anthropic account. You can either connect it to an API key for direct billing or use one of the plans. You can learn more on the [Claude Code](https://www.anthropic.com/claude-code) page.

<Callout type="info">
  GitButler does not charge you for agent use, but Anthropic does. This goes directly through Claude
  Code usage, we simply help manage the agent.
</Callout>

### Configuring the Agents Tab

Once Claude Code is installed, we can run it for you and provide both a branch-specific execution environment and a nice UI. There are some settings you can configure before using the tab, which you can access with the settings button:

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/CleanShot%202025-09-04%20at%2015.49.17%402x.png"
  width="800"
  height="600"
  subtitle="Agent settings modal"
/>

The first is the path for where we find the `claude` executable. You can also test to see if we can find it.

Then you can set some desktop notifications when Claude needs permission to do something or when a task is completed.

You can also auto-commit after a task is done, which will also generate a commit message from the prompt that you used and the diff that was introduced. If you prefer to do this yourself, we'll simply assign any modifications to the branch and let you commit it when you prefer.

Finally, if you don't want Claude to bug you every time it needs permissions for a bash command or something, you can put it in YOLO mode but dangerously allowing all permissions. This is not set by default, but if you're feeling adventurous, it's there for you.

# Generating Code in the Agents Tab

Once your agent is setup, you can select a branch to work on, type in a prompt and we will run that though Claude Code, same as if you ran it in the terminal.

We will do some cool things as it runs, however.

### One Branch Per Session

In GitButler, each branch is also an agent session with its own context. You can see each branch in the Agents Tab sidebar. If you add a new session, it will create a new branch to store the output of that. If you want to continue work on a branch, you can simply click on it to switch contexts.

You can have multiple agents working on branches at the same time - you can see which branches have active tasks running at a glance with the running indicator:

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/CleanShot%202025-09-05%20at%2011.34.07%402x.png"
  width="800"
  height="600"
  subtitle="Multiple branches, one has a running agent"
/>

<Callout type="warn">
  This won't _always_ work. If two agents modify lines in a file right next to each other, the hunk
  can only be assigned to one lane. In the future, we will be able to automatically stack these
  dependencies, but for now you just need to be aware that some post-commit moving things around may
  be needed on occasion.
</Callout>

### ToDo Breakout

Claude code typically will come up with a ToDo list, breaking down the steps it thinks it needs to do in order to get your task completed. It will update you on this as it goes, but it's easy for this to get lost in the conversation, so we intercept these updates and keep them in the sidebar for you:

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/CleanShot%202025-09-05%20at%2011.42.06%402x.png"
  width="800"
  height="600"
  subtitle="Simple TODOs example, with one item done, one running and three to go"
/>

### Folding Tool Calls

As the agent is running tool calls (read files, write files, run bash commands, etc), we fold the execution and results so it doesn't clutter up

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/CleanShot%202025-09-05%20at%2011.46.58.gif"
  width="800"
  height="600"
  subtitle="Folding and unfolding the agent tool calls"
/>

### Token and Cost Monitoring

Running agents costs money, so we try to keep you reminded of how much you're spending running these models.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/CleanShot%202025-09-05%20at%2011.52.08%402x.png"
  width="800"
  height="600"
  subtitle="Usage overview for the branch - tokens and estimated cost"
/>

These costs are estimates, it may differ if you're running on a plan versus using a metered API token.

### Model Selection

There are a few different models that you can choose from for running your task. You can change your active model in the model selection dialog of the chat box.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/CleanShot%202025-09-05%20at%2011.53.22%402x.png"
  width="800"
  height="600"
  subtitle="You can choose from any of the active Anthropic models"
/>

### Thinking Modes

Claude Code also allows for selection of a "thinking mode". The lower modes are faster, the higher modes tend to take longer and be more expensive, but can produce better results.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/CleanShot%202025-09-05%20at%2011.53.51%402x.png"
  width="800"
  height="600"
  subtitle="CleanShot 2025-09-05 at 11.53.51@2x.png"
/>

### Prompt Templates

If you find that you're using similar prompts over and over, you can easily setup several prompt templates. Selecting one will seed the prompt with the contents of that template.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/CleanShot%202025-09-05%20at%2011.56.50.gif"
  width="800"
  height="600"
  subtitle="Prompt templates"
/>

You can also edit your available templates by selecting the "Edit templates" option, which opens up our JSON file in your editor of choice. The templates look something like this:

````json
{
  "templates": [
    {
      "label": "Bug Fix",
      "template": "Please fix the bug in this code:\n\n```\n// Your code here\n```\n\nExpected behavior:\nActual behavior:\nSteps to reproduce:"
    },
    {
      "label": "Code Review",
      "template": "Please review this code for:\n- Performance issues\n- Security vulnerabilities\n- Best practices\n- Code style\n\n```\n// Your code here\n```"
    },
    {
      "label": "Refactor",
      "template": "Please refactor this code to improve:\n- Readability\n- Performance\n- Maintainability\n\n```\n// Your code here\n```\n\nRequirements:"
    },
    {
      "label": "Add Tests",
      "template": "Please write comprehensive tests for this code:\n\n```\n// Your code here\n```\n\nTest cases should cover:\n- Happy path\n- Edge cases\n- Error conditions"
    }
  ]
}
````

### Context Clearing

After a while, your context in a single branch can get long. If you no longer need all the context but want to keep your agent working on the same branch, you can clear it with the "Clear Context" button at the top of the screen.

### Modified Files Listing

As files are assigned and committed to your branch, you can see an overview of the changes made in the sidebar. You can also alt-click on them to open them directly in your editor if you want to make manual changes.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/CleanShot%202025-09-05%20at%2012.01.39%402x.png"
  width="800"
  height="600"
  subtitle="A list of your modified files for this session in the sidebar"
/>


# gerrit-mode.mdx

Not _everyone_ uses GitHub or GitLab to review code and collaborate. If you use the [Gerrit](https://www.gerritcodereview.com/) code review tool, GitButler has a mode for you! In fact, GitButler is the best Gerrit client there is.

## What is Gerrit

If you've never heard of Gerrit, it's used by large teams like the Android or Chrome projects to manage huge numbers of changes and users across large numbers of interdependent repositories.

Here is an example of incoming changesets on the [Android project](https://android-review.googlesource.com/q/status:open+-is:wip,50):

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/CleanShot%202025-10-17%20at%2016.03.44%402x.png"
  width="800"
  height="600"
  subtitle="The Android project's Gerrit code review"
/>

## How is Gerrit different than Pull/Merge Requests?

Good question. With GitHub or GitLab, when you send a pull/merge request, the review process is branch based. If you add more commits on top of your branch, the changes are squished into one big unified diff for review. Most teams tend to avoid rebasing anything that was already shared.

Gerrit is a commit based review system. Every review is based on exactly one commit. It's very common to edit shared commits and submit new versions of them to address feedback.

This model works _very well_ with GitButler's easy [commit editing](/features/branch-management/commits) features. With any other Git client, interactive rebasing and amending tends to be quite painful and error prone, making it fairly difficult to work with Gerrit's model. With GitButler, it's ideal. Just drag and drop changes and update your changesets easily.

## How to turn on Gerrit Mode

To turn on Gerrit Mode in GitButler, you just have to set a Git config option called `gitbutler.gerritMode` in the project you want to act in a Gerrit compatible fashion:

```
❯ cd my_project
❯ git config gitbutler.gerritMode 1
```

## What is Gerrit Mode

Now GitButler will change it's behavior in the following ways:

- When you commit, we will automatically inject a `Change-Id` trailer into the commit in the format that Gerrit expects. You do not need to [setup a `commit-msg` hook](https://gerrit-review.googlesource.com/Documentation/cmd-hook-commit-msg.html) like you do with other Git clients.
- When you push, it will not push to a matching branch name on the remote. Instead it will push to `refs/for/main` (or whatever the name of the target branch is set to be).
- After a push, we record the change url and show you the link and number for each commit automatically.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/CleanShot%202025-10-17%20at%2016.21.06%402x.png"
  width="800"
  height="600"
  subtitle="Gerrit Change numbers and URLs are shown and linked to"
/>

We can also set some extra push options when we push, including:

- [Topics](https://gerrit-review.googlesource.com/Documentation/cross-repository-changes.html)
- [Hashtags](https://gerrit-review.googlesource.com/Documentation/intro-user.html#hashtags)
- [WIP status](https://gerrit-review.googlesource.com/Documentation/intro-user.html#wip)

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/CleanShot%202025-10-17%20at%2016.50.07%402x.png"
  width="800"
  height="600"
  subtitle="Set a topic, hashtag or wip status on push"
/>


# timeline.mdx


Undo nearly any of your actions or go back in time to an earlier state.

## How it works

Before GitButler does any major action, it records the state of everything (your virtual branch state, your uncommitted work, conflict state, etc) and stores it in your Git object database as snapshots. You can hit the 'revert' button on any of the entries and it will restore the state of all of these things to what they looked like when they were recorded, letting you go back in time.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/oplog.png"
  width="800"
  height="600"
  subtitle="The operations history tab"
/>

## Restoring State

If you hover over any of the entries, you will see a button named "Revert" that will restore the state of things to right before you did that action. So if you revert one that says "Create Commit", it will put you where you were right before you made that commit.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/oplog-restore.png"
  width="800"
  height="600"
  subtitle="oplog-restore.png"
/>

## Recovering Content

Occasionally, GitButler will also take snapshots of files that were changed recently, even if they weren't committed. If this, or any other action, sees changes in files, you can see which ones and view the change by clicking on the file name.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/preview-oplog.png"
  width="800"
  height="600"
  subtitle="preview-oplog.png"
/>


# github-integration.mdx


GitButler integrates seamlessly with GitHub, allowing you to manage the pull requests associated with your branches directly from the GitButler client.

## Setting up GitHub Integration

To set up GitHub integration, you need to connect your GitButler client to your GitHub account. This is done through the GitButler settings.

Open the GitButler settings by clicking on the gear icon in the sidebar, then navigate to the "Integrations" tab, then click on the "Authorize" button for GitHub.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/github-setup-1.png"
  width="800"
  height="600"
  subtitle="GitHub authentication via the Integrations settings tab"
/>

Now copy the generated code and open the GitHub authorization page in your browser.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/github-copy-code.png"
  width="800"
  height="600"
  subtitle="github-copy-code.png"
/>

Once you are on the GitHub authorization page, paste the code into the input field and it should let you know that you are authorized.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/github-auth.png"
  width="800"
  height="600"
  subtitle="github-auth.png"
/>

## Using GitButler to Manage Pull Requests

Once you have set up GitHub integration, you can open your pull requests directly from the GitButler branch.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/create-pr.png"
  width="800"
  height="600"
  subtitle="create-pr.png"
/>

When you create a new branch or commit changes, GitButler will automatically check if there are any associated pull requests on GitHub. You can view these pull requests in the "Pull Requests" tab in the sidebar of the Branches page.


# gitlab-integration.mdx


Create your GitLab Merge requests without leaving GitButler.

## Setting up the GitLab Integration

In order to set up the GitLab integration, you will need two things. Firstly, a GitLab Personal Token and the Project ID for your project.

### Creating a GitLab Personal Token

To create a GitLab Personal Token, navigate to your GitLab preferences, and then click on the "Access tokens" tab. You will then see an "Add new token" button. Pressing this button will provide you with a form (as captured below) where you can specify the token name, expiration date, and scopes. We currently require the `api` scope. In this example, I've chosen to set the expiration date for the token to a year from now.

<ImageSection className="mx-auto" src="/gitlab/pat-create.png" />

On completion, you will be showen the following screen which contains your GitLab Personal token.

<ImageSection className="mx-auto" src="/gitlab/pat-created.png" />

### Finding your GitLab Project ID

Navigate to the main page of the repository you want to configure the integration for. On the top left next to the "Fork" button, you will see three dots. Click on those three dots, and click on "Copy project ID". This will copy the GitLab Project ID to your clipboard.

<ImageSection className="mx-auto" src="/gitlab/copy-project-id.png" />

### Configuring GitButler

Inside GitButler, navigate to the project settings by clicking on the small cog icon in the bottom left. Scroll down to the bottom of the "Project" tab where you will see a form for entering your GitLab details. The provided GitLab Personal Token will be stored securly in your operating system's keychain.

<ImageSection className="mx-auto" src="/gitlab/configure-gitbutler.png" />

### Custom GitLab Instances

You may also provide a different Instance URL if you are using a self-hosted GitLab instance.

Note that if you use a custom GitLab instance, you will likely need to configure a custom CSP (Content Security Policy) to allow GitButler to connect to it. You can find more information on how to do that in the [Custom Content Security Policy (CSP)](/troubleshooting/custom-csp) section of the documentation.

## Usage

You will now have a "Submit for Review" button on each branch which you can use to create a Merge Request.

<ImageSection className="mx-auto" src="/gitlab/submit-for-review.png" />

Once the Merge Request is created you will be able to see the status of it from within the client. Please note that we do not yet integrate with CI status.

<ImageSection className="mx-auto" src="/gitlab/review-card.png" />


# ai-assistance.mdx

## Getting Started

### Global AI Setup (One-time)

1. Navigate to **Global settings** → **AI Options**
2. Choose your AI provider:
   - **GitButler API** (default): Uses OpenAI through GitButler's servers - no API key needed
   - **Your own key**: Bring your own OpenAI, Claude, Ollama, or LM Studio credentials
3. If using your own key, enter your API credentials

### Per-Project Setup

1. Open **Project settings** → **AI options**
2. Enable **"Enable branch and commit message generation"**
3. Optionally enable **"Enable experimental AI features"** for advanced functionality

## Features

### Branch Name Generation

Automatically creates descriptive, kebab-case branch names based on your code changes.

**Usage:**

- Right-click on a branch header and select **Generate branch name**
- GitButler analyzes commit messages in the branch and suggests an appropriate name
- Generated names use kebab-case format and avoid conflicts with existing branches

### Commit Message Generation

Creates professional commit messages following best practices.

**Features:**

- Semantic prefixes (`feat:`, `fix:`, `refactor:`)
- 50-character title limit, 72-character body wrap
- Explains what changed and why
- Real-time streaming as AI generates the message
- Based on actual code diffs, not just file names

**Usage:**

1. Make changes to your files (staging is automatic in GitButler)
2. Click the **Generate message** button in the commit message editor
3. AI streams the generated message in real-time
4. Review and edit before committing

**Example format:**

```
feat: add user authentication system

Implements JWT-based authentication with login and registration
endpoints. Includes password hashing and session management
to secure user accounts.
```

### Pull Request Descriptions

Generates comprehensive PR descriptions when creating pull requests.

**Usage:**

1. Create a pull request from your branch
2. In the PR creation dialog, click **Generate PR description**
3. AI analyzes all commits in your branch and generates a description
4. Review and edit the generated content before creating the PR

**Generated content includes:**

- High-level summary based on commit messages
- Structured description following PR templates (if configured)
- Context derived from the changes in your branch

## Advanced Features

### Custom Prompts

- **Global Prompts**: Create custom prompts in **Global settings** → **AI Options**
- **Project-Specific Prompts**: Assign specific prompts per project in **Project settings** → **AI options**
- **Commit & Branch Prompts**: Separate customization for commit messages and branch names

## Configuration

### Global Settings (Global settings → AI Options)

- **AI Provider**: Choose between OpenAI, Anthropic, Ollama, or LM Studio
- **Key Options**: Use GitButler API or bring your own credentials for each provider
- **Model Selection**: Choose specific models per provider (GPT-4o, Claude Sonnet, etc.)
- **Amount of provided context**: Set how many characters of git diff to send to AI

### Project Settings (Project settings → AI options)

- **Enable branch and commit message generation**: Master toggle for AI features in this project
- **Enable experimental AI features**: Access to advanced AI functionality (requires GitButler API)
- **Custom prompts**: Assign specific prompts from global settings to this project for commits and branches

## Troubleshooting

**AI features not working?**

1. **Check Global Settings**: Navigate to **Global settings** → **AI Options** and verify:
   - AI provider is configured (OpenAI, Anthropic, etc.)
   - Key option is selected (GitButler API or your own key)
   - If using your own key, ensure it's entered correctly
   - Model is selected for your chosen provider
2. **Check Project Settings**: Open **Project settings** → **AI options** and ensure:
   - **"Enable branch and commit message generation"** is turned ON
   - This setting must be enabled for each project individually
3. **Verify API Access**: Ensure sufficient API quota and valid credentials

**AI buttons not appearing?**

- The project-level toggle in **Project settings** → **AI options** controls button visibility
- Without this enabled, Generate buttons won't appear in the UI

**Need better suggestions?**

- Customize prompt templates in **Global settings** → **AI Options**
- Make meaningful code changes with clear patterns
- Use descriptive variable names and comments in your code
- Review [troubleshooting guide](https://docs.gitbutler.com/troubleshooting/custom-csp) for advanced configurations


# branch-lanes.mdx


All of your branches - remote, local, and virtual / applied or not - are managed in the Branch Tab. This is where you can see all of your branches, apply them to your workspace, and manage your virtual branches.

You can access the Branches tab by clicking on the "Branches" icon in the sidebar.

The interface looks something like this:

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/branch-tab.png"
  width="800"
  height="600"
  subtitle="The branch tab"
/>

## Branch List

The first pane on the left shows you the virtual branches and stacks that you have as well as the other branches that you have available (legacy git branches, remote branches and PRs).

All of these branches can be converted into virtual branches by clicking them and then clicking the "Apply to workspace" button on the top of the branch view (middle pane).

Local branches can also be fully deleted here.

### Current Workspace Target

The "Current workspace target" is the view of the target branch that you've set. It will show you essentially a `git log` of `origin/master` or whatever you set as your target branch, and it will show you if there are any commits upstream that you have not integrated locally yet. We will automatically check for new upstream changes every few minutes, but you can also click the update button to check immediately.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/workspace-target.png"
  width="800"
  height="600"
  subtitle="workspace-target.png"
/>


# index.mdx

## Overview

GitButler is a new Source Code Management system designed to manage your branches, record and backup your work, be your Git client, help with your code and much more. Our focus is everything after writing code in your editor and before sharing it on GitHub. We're focused on your working directory and how we can help with everything you do there.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/vbranch-ex.png"
  width="800"
  height="600"
  subtitle="An example of the GitButler client with multiple applied branches and assigned changes."
/>

Here you will find documentation on the product and the way that we're running our beta and building our product with your help.

## Getting Started

Check out our [Getting Started](/guide) guide to get started with GitButler, or check out our helpful video overview:

https://www.youtube.com/watch?v=DhJtNNhCNLM

## Why We're Doing This

Read about it over [Why GitButler](/why-gitbutler) Section.

## What We Do

The GitButler client is a powerful Git client. You can manage your branches, work on multiple things at once, push and fetch from your Git server, easily rebase and modify commits and more. We have a unique approach to merge conflicts that help split up any conflicting work. It also keeps a timeline so that you can easily undo any operation.

- [Virtual Branches](/features/branch-management/virtual-branches)
- [First Class Conflicts](/features/branch-management/merging)
- [Project History](/features/timeline)



# merging.mdx


By default, GitButler rebases the work on your virtual branches when you update your target branch (upstream) work.

Often this works just fine and the commits are simply rebased. Occasionally, you will have conflicts with upstream work.

In this case, GitButler will not do what Git normally does, which is to stop at each conflicted commit and make you fix it before moving on. Instead, it will apply the changes that it can and store the commit as a "conflicted" commit and continue the rebasing process.

When you go to update from upstream, GitButler will show you all the branches that it will rebase and will let you know if any of them will have conflicts:

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/update-will-conflict.png"
  width="800"
  height="600"
  subtitle="Updating from upstream will let you know if there will be conflicts"
/>

In this case, when you perform the rebase, that branch will then contain "conflicted" commits. They will be marked in the UI as conflicted and you can click on them to get a "resolve conflict" button to start the resolution process.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/conflict-resolve.png"
  width="800"
  height="600"
  subtitle="When your commits have conflicts"
/>

When you click that, GitButler will remove the other virtual branches and other work from your working directory and check out just this commit with its conflict markers. It will show you a special "edit mode" screen, where you are directly editing this commit.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/resolve-conflicts-mode.png"
  width="800"
  height="600"
  subtitle="Resolving a conflict by individual commit"
/>

If you want to cancel this conflict resolution, you can just hit 'Cancel' and it will go back to your normal state. If you have fixed all the issues, you can click "Save and Exit" and it will commit the conflict resolution and if needed, rebase any further commits on that branch on top of your new work.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/conflicts-resolved.png"
  width="800"
  height="600"
  subtitle="conflicts-resolved.png"
/>


# commits.mdx


GitButler gives you a lot of tooling for creating, modifying, squashing, splitting and undoing commits.

GitButler has lots of ways to craft the exact commits that you want to end up with. With other Git clients, you tend to have to run somewhat complicated `git rebase -i` type commands to change commit messages, split a commit up or absorb new changes into an existing commit. With GitButler, most of these are simply drag-and-drop operations.

Here are some of the cool things you can do very easily with GitButler.

## Creating Commits

Once you have changes on a virtual branch and want to commit them, you can hit the "Start a Commit" button in any lane, which gives you an editor to write a summary and optional description for your commit message.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/commit-edit.png"
  width="800"
  height="600"
  subtitle="Crafting a commit message with our advanced floating mode editor"
/>

If you want AI to use your diff to generate a commit message, you can hit the "Generate message" button.

## AI Commit Message Settings

If you want to use AI for generating your commit messages or branch names from time to time, there are quite a few options in your user preferences. You can choose from [OpenAI](https://platform.openai.com/), [Anthropic](https://www.anthropic.com/), [Ollama](https://www.ollama.com/) or [LM Studio](https://lmstudio.ai/) as your engine.

For both OpenAI and Anthropic, you can either use your own API key to directly send your request to their servers, or you can proxy via our server (which you need to be logged in for).

<ImageSection alt="AI Commit Settings" src="/commits-02.png" />

If you use your own key for OpenAI or Anthropic, you can choose which model you would like us to use.

<ImageSection alt="AI Commit Settings" src="/commits-03.png" />

If you don't want to send your diff to another server, you can also use Ollama or LM Studio, which are a local LLM servers.

With Ollama, you can run nearly any open source large language model ([Llama 3](https://www.ollama.com/library/llama3), [Phi 3](https://www.ollama.com/library/phi3), [Mistral](https://www.ollama.com/library/mistral), [Gemma](https://www.ollama.com/library/gemma), etc) entirely locally.

Note that if you choose to configure a self-hosted Ollama server, you will likely need to add a custom CSP (Content Security Policy) to allow GitButler to connect to it.

You can find more information on how to do that in the [Custom Content Security Policy (CSP)](/troubleshooting/custom-csp) section of the documentation.

With all of these models, you can also customize the prompt if you want something more specific. In the "Custom AI prompts" section, you can add new prompts and select which one you want to use per project. This is useful for following certain formats or generating messages in other languages, etc.

<ImageSection alt="AI Commit Settings" src="/commits-04.png" />

Custom prompts can contain three variables which we will replace with the appropriate values. Those include:

- `%{emoji_style}` - Instructs the LLM whether or not to make use of [GitMoji](https://gitmoji.dev) in the title prefix, based on your settings.
- `%{brief_style}` - Instructs the LLM to not exceed 1 sentence when generating the commit message.
- `%{diff}` - The contents of the diff.
- `%{branch_name}` - The name of the current branch. Available in "Commit Message" custom prompt only.

## Absorbing New Work

If you have a commit and get some feedback on it or find an issue and wish to amend it, you can very easily absorb changes into existing commits. Simply drag the file into the commit you want to absorb that change into and drop it there.

This will both rewrite that commit to include the new changes and also rebase every commit upstream from it automatically.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/absorb-work.gif"
  width="800"
  height="600"
  subtitle="Assigning work on a file to a lane, then into an existing commit"
/>

## Undoing Commits

You can easily undo any commit in your stack by expanding the commit and hitting the 'Undo' button. This will rebase all the commits above it and leave whatever work was in that commit as new uncommitted changes.

<Callout>
  "Undo"ing a commit does not throw it away, it simply makes that work not in a commit anymore. It
  will not discard the changes.
</Callout>

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/undoing-commits.gif"
  width="800"
  height="600"
  subtitle="Undoing a commit in GitButler"
/>

## Undoing One File in a Commit

If you want to undo a single file in a commit, you can expand the commit and click on the file you want to undo. Then hit "Uncommit". This will remove that file from the commit and leave it as uncommitted changes.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/undoing-file-then-redoing.gif"
  width="800"
  height="600"
  subtitle="Uncommitting a file, then adding it back into the commit"
/>

## Squashing Commits

Squashing two commits into a single combined commit is also very simple. Just drag one commit on top of another one.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/squashing.gif"
  width="800"
  height="600"
  subtitle="Squash commits together by dragging and dropping"
/>

## Splitting Commits

Splitting commits is slightly more complex. GitButler allows you to create an "empty" commit anywhere and then drag changes into it. Here is an example of creating an empty commit between two other commits, dragging changes from both of them into it and then absorbing new work into it as well.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/splitting.gif"
  width="800"
  height="600"
  subtitle="Splitting commits by adding an empty commit and dragging changes into it"
/>

You can also notice that I easily edit the commit message by just hitting the "edit message" button.

## Moving Commits

You can also arbitrarily change the order of your commits by dragging and dropping them, which rebases everything to change the order.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/reorder.gif"
  width="800"
  height="600"
  subtitle="Reordering commits in a branch"
/>

## Edit Mode

The other way that you can modify a commit is to go into "Edit Mode". When you click on a commit, there is a button that says "Edit patch". If you click this, GitButler will check out that commit by itself into your working directory (automatically stashing everything else temporarily).

The screen will go into "Edit mode", indicating that you're in a special state where you're focusing on this one commit.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/edit-mode.gif"
  width="800"
  height="600"
  subtitle="Going into edit mode to directly edit the state of a commit"
/>

Then you can change whatever you want and when you click "Save and exit", it will amend the commit you were editing and rebase anything on top of it.

This is useful for things like getting feedback on a series and being able to go into the appropriate commit, make the changes and continue, as opposed to squashing work.


# pushing-and-fetching.mdx


GitButler can authenticate with an upstream Git server in several different ways.

 You can just tell us to use the system Git executable, which you can setup however you want. You can use our built in SSH protocol with your own SSH key (this does not require you to have Git installed), or you can use the default [Git credentials helper](https://git-scm.com/doc/credential-helpers).

You can set your preference (and test if it works) in your project's "Git authentication" section:

<ImageSection
  alt="Git Authentication Settings"
  src="/pushing.png"
/>

Once that's done, GitButler will be able to automatically fetch upstream work and push new branches to your upstream server.


# signing-commits.mdx


GitHub and GitLab provide a mechanism to verify signed commits using an uploaded public SSH or GPG key. GitButler can be configured automatically sign all your commits.

Git provides a mechanism to sign your commits with a GPG key or SSH key. This enables other developers to make sure that you were actually the person who committed it, rather than someone else just setting their email to yours and committing it as if they were you.

To make this work, a signature is added to the commit header and then that signature is checked against public key stored somewhere, generally for most people the most useful way to verify these signatures is through GitHub or GitLab.

This is what a verified commit looks like on both systems:

<ImageSection
  alt="Viewing Remote Branches"
  src="/signing-01.png"
  subtitle="A verified commit on GitLab."
/>

<ImageSection
  alt="Viewing Remote Branches"
  src="/signing-02.png"
  subtitle="Verified and non-verified commits on GitHub."
/>

This means that the server has a public key that you used to sign the commits that is associated to your account and has verified that this user actually signed this commit.

In order for this to work, you need to:

1. Tell GitButler to sign your commits
2. Upload your key as a "signing key" to GitHub or GitLab (or elsewhere)

## Telling GitButler to Sign

For GitButler to sign commits, you need to setup Git to sign commits, as we do roughly the same thing that Git itself tries to do, and we read and respect most of the same Git config settings.

The main difference is that instead of only the `commit.gpgSign` as the flag that tells Git to automatically sign commits, we look for `gitbutler.signCommits` first. Thus, if Git would sign, GitButler will attempt to sign your commits with the normal Git settings as well.
But if something goes wrong, `gitbutler.signCommits` will be set to `false` in the repository-local settings to prevent commits from
failing generally.

We look to see if we have a signing key in `user.signingkey`. If we have a key, we look for 'ssh' in `gpg.format`, otherwise we use GPG. We will respect `gpg.ssh.program` for ssh if there is a different binary path, and `gpg.program` for GPG. We also identify literal SSH keys in the `user.signingkey` field.

The only major thing we don't support yet is `gpg.ssh.defaultKeyCommand` for other ways to get a key other than the `user.signingkey` field. We also don't support the X.509 smime stuff.

Here is an example, if you have a public key here `.ssh/id_ed25519.pub` then you can setup signing with something like this:

```bash title="Terminal"
$ git config --global user.signingkey "/Users/schacon/.ssh/id_ed25519.pub"
$ git config --global gpg.format ssh
$ git config --global gitbutler.signCommits true
```

You can also set this up in your project settings, perhaps a little more easily:

<ImageSection
  alt="Viewing Remote Branches"
  src="/signing-03.png"
/>

The nice thing here is that you can also test the settings easily by hitting the "Test Signing" button.

There are lots of other ways to set up GPG or SSH commit signing:

- 1Password is a very easy way to [SSH sign commits](https://blog.1password.com/git-commit-signing/).
- GitHub has a [good guide](https://docs.github.com/en/authentication/managing-commit-signature-verification/telling-git-about-your-signing-key) on how to setup GPG or SSH keysigning.
- Here is a nice simple gist for [GPG signing on Windows](https://gist.github.com/BoGnY/f9b1be6393234537c3e247f33e74094a).

<Callout title="Using GitButler's Generated SSH Key">
Earlier versions of GitButler would only sign with its generated SSH key. Although we've removed that functionality, you can easily set it back up by pointing the signingKey at the generated SSH Key. The key is located in the following locations:

<Tabs groupId="platform" items={['macOS', 'Windows', 'Linux']} persist>
  <Tab value="macOS">
  ```bash
  /Users/[username]/Library/Application Support/com.gitbutler.app/keys/ed25519.pub
  ```
  </Tab>
  <Tab value="Windows">
  ```bash
  C:\Users\[username]\AppData\Roaming\com.gitbutler.app\keys\ed25519.pub
  ```
  </Tab>
  <Tab value="Linux">
  ```bash
  ~/.local/share/gitbutler-tauri/keys/ed25519.pub
  ```
  </Tab>
</Tabs>

</Callout>

## Upload Your Signing Key

For GitHub or GitLab to verify your signatures, you need to say that the SSH or GPG public key we are using is a valid signing key for your user.

### Adding to GitHub

You can click on the "Add key to GitHub" link in the settings page right about the signing toggle, or you can go here (https://github.com/settings/ssh/new) to paste that public key in.

<ImageSection
  alt="Adding a key to GitHub"
  src="/signing-04.png"
  subtitle="Be sure to change the type to 'Signing Key'"
/>

Now your signed commits should show up as "Verified".

### Adding to GitLab

For GitLab you need to go to "SSH Keys" in your profile: https://gitlab.com/-/profile/keys and click the "Add new key" button.

<ImageSection
  alt="Adding a key to GitHub"
  src="/signing-05.png"
  subtitle="Add new key here."
/>

Now paste in the public SSH key you copied from GitButler, name it and make sure the "Usage Type" is either "Signing" or "Authentication and Signing".

<ImageSection
  alt="Adding a key to GitHub"
  src="/signing-06.png"
  subtitle="Now all your GitButler generated commits will be verified on that platform!"
/>


# upstream-integration.mdx

Sometimes you work on a branch and someone else pushes to the same upstream branch. Often you won't know this until you try to push and Git tells you something like this:

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/CleanShot%202025-09-12%20at%2014.49.08%402x.png"
  width="800"
  height="600"
  subtitle="Oh no, someone else has pushed!"
/>

In this scenario, GitButler gives you some nice tooling to help you know when this happens as early as possible and help you deal with it easily.

If someone else has pushed to a branch that you're working on, you will see the upstream commits without having to integrate them. You can look at the commits without having to merge them into your branch or rebase your work on top of them.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/CleanShot%202025-09-12%20at%2014.42.06%402x.png"
  width="800"
  height="600"
  subtitle="GitButler's view when someone else has pushed"
/>

When you decide that you do want to integrate the changes, you have two options - rebase or interactively integrate.

## Rebase the changes

If you select "Rebase upstream changes", it will do the equivalent of a `git pull --rebase` which rebases the commits you have locally on top of the ones that the other person has pushed, so you end up with a state like this:

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/CleanShot%202025-09-12%20at%2015.08.05%402x.png"
  width="800"
  height="600"
  subtitle="Simple rebase of my changes on top of the upstream changes"
/>

Now you can push your commit back upstream without a force push. Easy peasy.

## Interactively integrate the changes

However, let's say that you want to do something more complex. Maybe the other implemented the same thing that you did and you want to drop one of them or one of yours, or squash commits together or reorder them. In any of these cases, you can choose the "Interactive integration" option and you get something that looks like this:

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/CleanShot%202025-09-12%20at%2014.42.42%402x.png"
  width="800"
  height="600"
  subtitle="Upstream integration helper"
/>

Here you can reorder commits however you want, you can choose to skip some of them, you can squash some of them down, etc. Just make the commits look however you prefer and then hit the "Integrate changes" button and push your final result back to the server.


# virtual-branches.mdx


Virtual branches are a powerful feature of GitButler that allow you to work on multiple branches at the same time, committing to them independently and simultaneously. This is a key part of the GitButler experience, allowing you to manage your work in a flexible and efficient way that is not possible with traditional Git tooling.

## Overview

With normal Git branching, you can only work on one branch at a time. There is one `HEAD` reference and one index.

With virtual branches, you can have multiple branches applied to your working directory at the same time. Each branch is represented as a vertical lane, and you can drag changes between these lanes to commit them independently.

Each lane also has its own staging area, so you can stage changes for each branch before deciding to commit them.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/vbranch-ex.png"
  width="800"
  height="600"
  subtitle="A project with three simultaneous branches, plus some staged changes in each one and some unstaged (unassigned) changes."
/>

## How it works

Let's say that you make changes to two different files and `git status` would list two modified files. In GitButler, you can "assign" the change in each file to a different "virtual" branch, then when you commit, it will create a commit that only contains the changes in that file for that branch.

One of the nice things with this approach is that since you're starting from changes in a single working directory, you can be sure that all branches that you create from it will merge cleanly, as you're essentially starting from the merge product and extracting branches of work from it.


# stacked-branches.mdx


Create a stack of dependent branches to be reviewed and merged in order.

## Overview

GitButler allows you to create an ordered stack of branches where each branch depends on (and is based on) the previous one.
The application also supports creating the appropriate stacked Pull Requests (when used with a GitHub remote).
This is useful when you have multiple changesets that depend on each other but it is desirable to have them reviewed and merged separately (and in sequence).

> All of the Pull Request stack orchestration is done locally in the client, which means that your repo content is not shared with a cloud service.

<ImageSection className="mx-auto" src="/stacked-branches/0_concepts.jpg" />

## Use cases

Using stacked branches (Pull Requests) can be helpful for shipping smaller changes more frequently.

### Breaking up a larger change into smaller ones

Consider a scenario where you are implementing a medium/large feature in your software project.
In the course of implementation you end up performing the following sub-tasks:

1. Refactor a part of the codebase to accommodate the new feature
2. Implement an API endpoint supporting the feature
3. Implement the frontend part of the feature consuming the API

While the feature is considered complete only when all of the subtasks are implemented, reviewed and merged, in many cases it is considered beneficial
to ship each stage of the feature on its own, potentially behind a feature flag. Not only the risk of merge conflicts with colleagues is reduced,
but also eventual bugs are easier to track down / revert / fix as compared to a single large change.

### More granular (easier) review process

On GitHub at least, code reviews are performed on per-branch basis. While it is possible to view individual commits in a Pull Request, it is not possible to
approve and merge a subset of commits from the PR.

Utilizing stacked pull requests, means that the sub-tasks of a larger change are in their own PRs.
This way it is possible to approve and merge the initial part of a stack (e.g. a refactor) while still iterating on the remaining sub-tasks.

## Comparison to Virtual Branches

Stacking and Virtual Branches are similar in that they allow you to separate code changes / commits into different branches. In both cases,
the changes are available in your working directory.

The main difference is that Virtual Branches are **independent** from one another, while stacked branches **depend** on the ones that come before it.
Because of this, the two features are not mutually exclusive but rather complementary. For example a bugfix change that is unrelated to a feature
can be put in a separate virtual branch. On the other hand, a change that depends on a previous change can be put in a stacked branch above the one it depends on.

In fact GitButler implements stacked branches as Virtual Branches that are split into multiple dependent branches.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/stacked-branches.png"
  width="800"
  height="600"
  subtitle="stacked-branches.png"
/>

## Workflow

By default, virtual branches in the app are simply stacks of one.
With version `0.14.0` or newer you can create a new dependent branch within a lane by clicking the `+` button above the branch name.

> The workflow below assumes a GitHub remote. If you are using a different forge, you can still use this functionality but will need to manually create/update the Pull/Merge Requests

1. Creating a new dependent branch forms a stack within the lane.

<ImageSection src="/stacked-branches/1_creating_stack.jpg" />

2. New commits land in the top branch of the stack.

<ImageSection src="/stacked-branches/2_new_commits.jpg" />

3. Pushing is done for the stack as a whole. Note: The Pull Requests will be created in a way where each branch points to its parent - see [Automatic branch deletion](#automatic-branch-deletion)

<ImageSection src="/stacked-branches/3_push_all.jpg" />

4. Pull requests must be created one at a time starting from the bottom of the stack.

<ImageSection src="/stacked-branches/4_create_pr.jpg" />

5. The PRs will contain a footer with stack information, and as you add more PRs it will keep all up to date.

<ImageSection src="/stacked-branches/5_pr_footer.jpg" />

6. You can drag changes into commits to amend them (e.g. incorporating review feedback) as well as move and squash commits.

<ImageSection src="/stacked-branches/6_modify_commits-amend.jpg" subtitle="Amending a commit" />
<ImageSection
  src="/stacked-branches/6_modify_commits-move.jpg"
  subtitle="Moving a commit to a different branch"
/>
<ImageSection src="/stacked-branches/6_modify_commits-squash.jpg" subtitle="Squashing commits" />

7. If a change in your stack is independent (e.g. an unrelated bugfix) it can be moved to a different virtual branch (or stack).
   This works for both uncommitted changes and existing commits that you may want to relocate.

<ImageSection src="/stacked-branches/7_move_to_vb.jpg" />

8. Review/merge your PRs starting from the bottom up. After a PR/branch from your stack has been merged, it is reflected in the Stack and you should force push to reflect the changes
   on the remote as well.

<ImageSection src="/stacked-branches/8_merging-1.jpg" />
<ImageSection src="/stacked-branches/8_merging-2.jpg" />

9. When all branches of a stack have been merged, the stack is complete.

## GitHub configuration for stacked PRs

_TLDR:_

1. Enable automatic branch deletion [automatic branch deletion](https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/managing-the-automatic-deletion-of-branches)
   on GitHub.
2. If possible, consider using the the "Merge" strategy when merging PRs.

#### Automatic branch deletion

When reviewing a PR in a stack, it is important to be able to view only the changes in the branch that is being reviewed.
Of course, in pure Git terms, a stacked branch will contain all the changes from the branches below it.

In order to show only the expected Files changed and Commits for PRs in a stack, each PR is created to target the branch below it in the stack.
This is true for all but the bottom branch in the stack, which targets the default branch of the repository as usual.

<ImageSection src="/stacked-branches/9_pr_heads.jpg" />

> Every branch in the stack contains the commits from the branches below it.

This of course does not mean that a Pull Request should be merged into its parent.
When the bottom branch is merged on GitHub, **if** the PR branch is deleted,
GitHub will automatically update any PRs that used to target it to target the default branch instead.

<ImageSection src="/stacked-branches/10_branch_deletion.jpg" />

If the newly merged branch from the bottom of the stack is not deleted, the next PR in line will still target it and there is a risk of accidentally merging it into the now out of date branch.
For this reason it is _highly recommended_ to [enable on GitHub](https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/managing-the-automatic-deletion-of-branches) the automatic deletion of branches after merging.

_NB:_ If you merge the first PR but the branch is not deleted and then merge the second PR,
the app can still recover from this, see [Troubleshooting](#troubleshooting).

#### Merge strategy

The app will support any merge strategy you wish to use - "Merge", "Rebase" or "Squash". However, due to the nature of merge,
the GitButler will be able to create a slightly better experience if the "Merge" strategy is used.
The reason for this is with merge commits you will be able to merge all the branches in the stack from GitHub without having to force push in the app.

## Troubleshooting

Firstly, if you run into any issue with the app (stacking or not), you can always get in touch either
on [Discord](https://discord.com/invite/MmFkmaJ42D) or via the in-app feedback icon (we will get back via email).
With that said, here are some workarounds for common issues.

#### Accidentally merged a stack branch into an already merged branch before it

If you merged the bottom Pull Request into main but the branch was _not_ deleted, then the target of the next Pull Request would not be automatically updated.
Under these conditions merging that next Pull Request, means it would be merged into the original, now out of date, bottom PR.

A mitigation for this is to rename the branch, push and re-create the Pull Request.

#### Accidentally merged a branch into a branch before it (not integrated into main/master yet)

Merging of branches in a stack should be done from the bottom up. With the GitHub interface, it is possible to incorrectly merge a Pull Request which is in the middle of the stack.
In this case it will merged in the parent branch.

In order to recover from this situation you can simply force push the branches and then re-create the PR that was incorrectly merged.


# ai-overview.mdx


If you're using AI agent tools like Cursor, Windsurf, or Claude Code, GitButler can enhance your coding experience by managing commits, saving points, and more. These integrations allow you to focus on coding with your agents while GitButler handles the version control aspects.

https://www.youtube.com/watch?v=J6xV_Wyz9zg

There are currently three main ways to use AI tools with GitButler:

1. **Our Agents Tab**: If you have Claude Code setup, you can use our [Agents tab](/features/agents-tab) as a GUI for running Claude Code directly.
2. **Using Hooks in Claude Code or Cursor**: This method allows you to use GitButler's CLI as hook commands to manage commits and branches in either Claude Code or Cursor.
3. **Using the MCP Server**: This method allows you to set up your AI agent to communicate with GitButler's MCP server, enabling features like automatic commits and save points.

## Enabling the experimental feature flag

Note that as of GitButler version `0.15.2` these features have to be enabled via an experimental feature flag. You can find that under `Global Settings` -> `Experimental` -> `GitButler Actions`.


# cursor-hooks.mdx

GitButler integrates seamlessly with Cursor through hooks that automatically manage your commits and branches while you're using AI coding features. This allows you to automatically maintain clean git history and organized virtual branches.

Here's a short video showing how GitButler works with Cursor hooks:

https://youtu.be/NOYK7LTFvZM

Ok, let's get it set up.

## Install the GitButler CLI

First, you need to install the GitButler CLI, which can be done in your General settings. See the [MCP Server documentation](mcp-server) for more details on how to install the CLI.

## Installing GitButler as a Hook

Once the command line tool is installed, you can add the `but cursor` commands as hooks.

You will need to create or edit your `~/.cursor/hooks.json` file (globally) or `[project]/.cursor/hooks.json` file (single project) to have `afterFileEdit` and `stop` hooks like this:

```json
{
  "version": 1,
  "hooks": {
    "afterFileEdit": [
      {
        "command": "but cursor after-edit"
      }
    ],
    "stop": [
      {
        "command": "but cursor stop"
      }
    ]
  }
}
```

## Using GitButler with Cursor

Once the hooks are setup, Cursor will automatically call GitButler when it edits files and when it's done with a task, which will trigger GitButler to:

- Create a branch if the chat session is new
- Assign edits to an active branch
- Commit with a message based on the prompt when a task is done


# mcp-server.mdx


If you use an AI agent (such as Cursor, Windsurf, Claude Code) to help you with your code, you can easily setup GitButler to manage your commits automatically, keep save points, and more. You know, _vibe_ commit...

## Setting up your Agent to use GitButler

The first step is to let your agent know about GitButler, which is done via MCP - you need to tell your agent to use the GitButler MCP server.

### Installing the CLI

GitButler provides a CLI that can be used to interact with the GitButler platform. Before you can setup AI Agent integration, you will need to install the CLI.

This can be found by opening the GitButler global settings, and then clicking on the "Install CLI" button in the General settings.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/install-cli.png"
  width="800"
  height="600"
  subtitle="How to install the GitButler CLI"
/>

Now that you have the `but` CLI installed, your agent can use the CLI's MCP server to interact with GitButler.

### Cursor

To install the GitButler MCP server in Cursor, first go to the Cursor settings, and then click on the "Extensions" tab, then click on "Tools and Integrations" and click on "New MCP Server".

This will open your `~/.cursor/mcp.json` file.

Add the following to the `mcpServers` object:

```json
{
  "mcpServers": {
    "gitbutler": {
      "command": "but",
      "args": ["mcp"]
    }
  }
}
```

You should see the GitButler MCP server in the list of MCP servers and it should have the tool `gitbutler_update_branches` available.

### VSCode

To install the GitButler MCP server in VSCode, you need to select "MCP: List Servers" from the actions menu. Then select "Add Server". Select "stdio" as the server type.

Now you can type your command (`but mcp`) and name it something. After this, it should open up your settings file and show you something like this:

```json
  "mcp": {
    "servers": {
      Running | Stop | Restart | 1 tools
      "gitbutler-mcp": {
        "type": "stdio",
        "command": "but",
        "args": ["mcp"]
      }
    }
  }
```

However, if you have Cursor's MCP already setup, VSCode will notice and help you automatically reuse the settings.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/vscode-mcp-cursor.png"
  width="800"
  height="600"
  subtitle="vscode-mcp-cursor.png"
/>

### Claude Code

Adding an MCP server to Claude Code is done by running the `claude mcp add` command.

```
❯ claude mcp add gitbutler but mcp
Added stdio MCP server gitbutler with command: but mcp to local config

❯ claude mcp list
gitbutler: but mcp
```

## Rules: How to configure auto committing

Once you have installed the MCP server in your editor or agent, you can optionally configure it to automatically commit your changes.

We've found that adding something like this to your rules works well:

```
If you generate code or modify files, run the gitbutler update branches MCP tool.
```

## How to add rules

Cursor stores its rules in `~/.cursor/rules` file, but you can also manually set them by going to the Cursor Settings pane, clicking 'Rules' and adding them to the User Rules section.

In VSCode's Copilot Agent Mode, you can use ["custom instructions"](https://code.visualstudio.com/docs/copilot/copilot-customization#_custom-instructions) to accomplish this.

In Claude Code, they are now called "memories" and you can add them by hitting '#' and storing them in user memory (or local if you just want them in one project).

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/claude-memories.png"
  width="800"
  height="600"
  subtitle="Adding memories in Claude Code"
/>

Or directly in your `~/.claude/CLAUDE.md` rules file:

```
❯ cat ~/.claude/CLAUDE.md
## Development Workflow
- When you're done with a task where code was created or files edited, please run the gitbutler mcp update_branches command.
```

## Using GitButler with your agent

If you've set up a rule/instruction/memory, then every time a chat session is completed, the agent will send the changes and prompt to GitButler and it will automatically commit the changes.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/update-branches.png"
  width="800"
  height="600"
  subtitle="Notice the automatic 'Called gitbutler_update_branches' after a change was made"
/>

If you're using Claude Code, it may look something like this:

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/claude-mcp-call.png"
  width="800"
  height="600"
  subtitle="Claude Code will show the full MCP prompt after a change was made"
/>

If you don't have the agent setup to automatically call our tool, then you can also just manually type 'update gitbutler branches' in the chat, but that's a little less magical.

## GitButler interface

There are two phases to GitButler's MCP agent interaction. The first is the agent sending the changes and prompt to GitButler, which GitButler will quickly record and then return a success to the agent. The second is GitButler processing that raw recorded change and attempting to process that change into a commit.

### Recording the changes

When your agent calls the `gitbutler_update_branches` tool, GitButler will record the changes and prompt and then immediately return to the agent, so the call should be very fast.

So for instance, let's say that I prompted my coding agent to update my `README.md` file to add a list of contributing authors. When the agent is done, it should call the update branches MCP tool, which will record a commit that looks something like this:

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/commit-raw.png"
  width="800"
  height="600"
  subtitle="The recorded commit message with prompt and summary data from the agent"
/>

### Processing the changes

Then, if you have AI tooling setup, GitButler will see that and turn it into a commit message like this:

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/commit-updated.png"
  width="800"
  height="600"
  subtitle="The updated commit message"
/>

You can see all of these steps in the "Actions" section of the GitButler interface, which you can toggle by hitting the "Actions" button in the top right of the interface.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/actions.png"
  width="800"
  height="600"
  subtitle="The 'Actions' section of the GitButler interface"
/>

In the near future, we will also be able to do more interesting things like auto-absorbing changes into existing commits, creating new branches based on the prompt theme, creating stacked branches, and more.


# contact-us.mdx


There are a few ways to get in touch with us for feedback, bug reports, feature requests, etc.

<Cards>
  <Card
    icon={<svg className="size-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><rect width="256" height="256" fill="none"/><line x1="108" y1="148" x2="160" y2="96" fill="none" stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="16"/><path d="M223.69,42.18a8,8,0,0,0-9.87-9.87l-192,58.22a8,8,0,0,0-1.25,14.93L108,148l42.54,87.42a8,8,0,0,0,14.93-1.25Z" fill="none" stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="16"/></svg>}
    href="mailto:hello@gitbutler.com"
    title="Email"
    description="The simplest way to get in touch with us is to email us"
  />
  <Card
    icon={<svg className="size-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><rect width="256" height="256" fill="none"/><circle fill="currentColor" cx="92" cy="140" r="12"/><circle fill="currentColor" cx="164" cy="140" r="12"/><path d="M153.44,73.69l5-19.63a8.1,8.1,0,0,1,9.21-6L203.69,54A8.08,8.08,0,0,1,210.23,60l29.53,116.37a8,8,0,0,1-4.55,9.24l-67,29.7a8.15,8.15,0,0,1-11-4.56L147,183.06" fill="none" stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="16"/><path d="M102.56,73.69l-5-19.63a8.1,8.1,0,0,0-9.21-6L52.31,54A8.08,8.08,0,0,0,45.77,60L16.24,176.35a8,8,0,0,0,4.55,9.24l67,29.7a8.15,8.15,0,0,0,11-4.56L109,183.06" fill="none" stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="16"/><path d="M80,78.31A178.94,178.94,0,0,1,128,72a178.94,178.94,0,0,1,48,6.31" fill="none" stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="16"/><path d="M176,177.69A178.94,178.94,0,0,1,128,184a178.94,178.94,0,0,1-48-6.31" fill="none" stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="16"/></svg>}
    href="https://discord.com/invite/MmFkmaJ42D"
    title="Discord"
    description="We are also available to chat on our Discord server"
  />
</Cards>


# claude-code-hooks.mdx

If you are using Claude Code, you can use the new ["hooks"](https://docs.anthropic.com/en/docs/claude-code/hooks) functionality to manage the output of even multiple simultaneous instances, while isolating all the generated code into virtual or stacked branches automatically. In this case, there is no need to set up the MCP server, as the hooks will handle everything for you.

Here's a short video showing how GitButler works with Claude Code:

https://youtu.be/AwwPwSc9qhA

Ok, let's get it set up.

## Install the GitButler CLI

First, you need to install the GitButler CLI, which can be done in your General settings. See the [MCP Server documentation](./mcp-server) for more details on how to install the CLI.

## Installing GitButler as a Hook

Hooks in Claude Code are defined in one of your settings files.

```
~/.claude/settings.json - User settings
.claude/settings.json - Project settings
.claude/settings.local.json - Local project settings (not committed)
```

Wherever you want to add GitButler to handle your commits automatically, you can add us as a hook by adding the following to the `hooks` array in whatever settings file you want to use:

```json
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Edit|MultiEdit|Write",
        "hooks": [
          {
            "type": "command",
            "command": "but claude pre-tool"
          }
        ]
      }
    ],
    "PostToolUse": [
      {
        "matcher": "Edit|MultiEdit|Write",
        "hooks": [
          {
            "type": "command",
            "command": "but claude post-tool"
          }
        ]
      }
    ],
    "Stop": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "but claude stop"
          }
        ]
      }
    ]
  }
}
```

Essentially, you want to run the `but claude pre-tool` command before any code generation or editing, and the `but claude post-tool` command after it. The `but claude stop` command will run when you stop the agent, ensuring that all changes are committed and branches are updated accordingly.

You also might want to add to your "memories" to ask Claude not to try commiting using Git as it will be handled by GitButler. You can do something like this:

```
❯ cat ~/.claude/CLAUDE.md
## Development Workflow
- Never use the git commit command after a task is finished.
```

## Using GitButler with Claude Code

With the hooks setup, Claude will tell GitButler when it has generated code or edited files and in which session, which helps GitButler to try to isolate the changes into a single branch per session.

For example, if you have three sessions of Claude Code running at the same time, each will be communicating with GitButler at each step and GitButler will be assigning each change to the correct branch automatically.

When the agent is done, GitButler will commit all the changes and write a more sophisticated commit message based on what you had prompted your agent.


# debugging.mdx


If you are having technical issues with the GitButler client, here are a few things you can do to help us help you. Or help yourself.

If you get stuck or need help with anything, hit us up over on Discord, here's [GitButler Discord Server Link](https://discord.gg/MmFkmaJ42D).

<img src="/img/nothing-found.svg" className="w-56 mx-auto" />

The first things to try is checking out the frontend related logs in the console by opening the developer tools in GitButler via the "View" -> "Developer Tools" menu option. Next, if you launch GitButler from the command line, you can view the backend logs directly in your terminal.

## Logs

Often the most helpful thing is to look at the logs. GitButler is a Tauri app, so the logs are in your OS's [app log directory](https://docs.rs/tauri/1.8.1/tauri/api/path/fn.app_log_dir.html). This should be:

<Tabs groupId="platform" items={['macOS', 'Windows', 'Linux']} persist>
  <Tab value="macOS">
  ```bash
  ~/Library/Logs/com.gitbutler.app/
  ```
  </Tab>
  <Tab value="Windows">
  ```bash
  C:\Users\[username]\AppData\Local\com.gitbutler.app\logs
  ```
  </Tab>
  <Tab value="Linux">
  ```bash
  ~/.config/gitbutler/logs/        [OR]
  ~/.local/share/gitbutler-tauri/logs/
  ```
  </Tab>
</Tabs>

In this directory, there should be rolling daily logs:


```bash title="Terminal"
❯ cd ~/Library/Logs/com.gitbutler.app

❯ tree -L 1

├── GitButler.log
├── GitButler.log.2023-09-02
├── GitButler.log.2023-09-03
├── GitButler.log.2023-09-04
├── GitButler.log.2023-09-05
├── GitButler.log.2023-09-06
├── GitButler.log.2023-09-07
├── GitButler.log.2023-09-08
├── GitButler.log.2023-10-10
├── GitButler.log.2024-01-30
└── tokio-console

❯ tail GitButler.log.2024-01-30
2024-01-30T13:02:56.319843Z  INFO get_public_key: gitbutler-app/src/keys/commands.rs:20: new
2024-01-30T13:02:56.320000Z  INFO git_get_global_config: gitbutler-app/src/commands.rs:116: new key="gitbutler.utmostDiscretion"
2024-01-30T13:02:56.320117Z  INFO git_get_global_config: gitbutler-app/src/commands.rs:116: new key="gitbutler.signCommits"
2024-01-30T13:02:56.320194Z  INFO get_public_key: gitbutler-app/src/keys/commands.rs:20: close time.busy=317µs time.idle=47.0µs
2024-01-30T13:02:56.320224Z  INFO git_get_global_config: gitbutler-app/src/commands.rs:116: close time.busy=204µs time.idle=25.3µs key="gitbutler.utmostDiscretion"
2024-01-30T13:02:56.320276Z  INFO git_get_global_config: gitbutler-app/src/commands.rs:116: close time.busy=133µs time.idle=35.8µs key="gitbutler.signCommits"
2024-01-30T13:02:56.343467Z  INFO menu_item_set_enabled: gitbutler-app/src/menu.rs:11: new menu_item_id="project/settings" enabled=false
2024-01-30T13:02:56.343524Z  INFO menu_item_set_enabled: gitbutler-app/src/menu.rs:11: close time.busy=35.7µs time.idle=28.8µs menu_item_id="project/settings" enabled=false
```


## Data Files

GitButler also keeps its own data about each of your projects. The virtual branch metadata, your user config stuff, a log of changes in each file, etc. If you want to inspect what GitButler is doing or debug or reset everything, you can go to our data directory.

<Tabs groupId="platform" items={['macOS', 'Windows', 'Linux']} persist>
  <Tab value="macOS">
  ```bash
  ~/Library/Application Support/com.gitbutler.app/
  ```
  </Tab>
  <Tab value="Windows">
  ```bash
  C:\Users\[username]\AppData\Roaming\com.gitbutler.app
  ```
  </Tab>
  <Tab value="Linux">
  ```bash
  ~/.local/share/gitbutler-tauri/
  ```
  </Tab>
</Tabs>

In this folder there are a bunch of interesting things.


```bash title="Terminal"
❯ cd ~/Library/Application\ Support/com.gitbutler.app

❯ tree
.
├── keys
│   ├── ed25519
│   └── ed25519.pub
├── projects.json
└── settings.json

4 directories, 4 files
```


The `projects.json` file will have a list of your projects metadata:


```bash title="Terminal"
❯ cat projects.json
[
  {
    "id": "71218b1b-ee2e-4e0f-8393-54f467cd665b",
    "title": "gitbutler-blog",
    "description": null,
    "path": "/Users/scottchacon/projects/gitbutler-blog",
    "preferred_key": "generated",
    "ok_with_force_push": true,
    "api": null,
    "gitbutler_data_last_fetch": null,
    "gitbutler_code_push_state": null,
    "project_data_last_fetch": {
      "fetched": {
        "timestamp": {
          "secs_since_epoch": 1706619724,
          "nanos_since_epoch": 202467000
        }
      }
    }
  }
]
```


The `settings.json` are some top level preferences you've set.


```bash title="Terminal"
❯ cat settings.json
{
  "appAnalyticsConfirmed": true,
  "appNonAnonMetricsEnabled": true
}
```


Finally, the `keys` directory holds the SSH key that we generate for you in case you don't want to go through creating your own. It's only used if you want to use it to sign commits or use it for authentication.

## Linux

### `glibc` Errors

The Linux installation is currently being built in a GitHub Action with Ubuntu 24.04. This means support is limited to those installations using the same or newer version of `glibc`. Unfortunately we cannot build using earlier versions of Ubuntu due to another incompatibility with `libwebkit2gtk-4.1` and Tauri at the moment.

If you're using an older distribution, you may be interested in trying our Flatpak package available on Flathub.

### `Failed to create EGL image from DMABuf`

If you start GitButler from the command line and see a bunch of these or similar `EGL` / `DMABuf` related messages printed to the console and are only getting a white screen to render, you can try launching GitButler with the following environment variables:

- `WEBKIT_DISABLE_DMABUF_RENDERER=1`
- `WEBKIT_DISABLE_COMPOSITING_MODE=1`

This issue most likely stems from an incompatibility between your version of OpenGL (`mesa`) and `libwebkit2gtk-4.1`.


# supporters.mdx


Thinking about paying for Beta software? Sounds odd, right?

No worries, the main stuff in GitButler stays the same whether you pay or not.

But hey, we're all about building a cool gang here. We want to know who really digs our butler. And those early supporters? They're like VIPs to us.

## Perks for Early Supporters

- Access to our Early Bird Discord room, for life
- Invitations to exclusive Berlin parties, when it's warm here
- Care packages of schwag, sent your way
- Pricing locked in, no matter how we decide to charge later
- First look at any new features as we go
- Whatever else we can think of over time

Your support helps us grow and make GitButler even better. Join us on this adventure!

## How to Support Us
You need to have a GitButler account to support us. If you don't have one, sign up first.

<Cards>
  <Card
    icon={<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><rect width="256" height="256" fill="none"/><ellipse cx="96" cy="84" rx="80" ry="36" fill="none" stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="16"/><path d="M16,84v40c0,19.88,35.82,36,80,36s80-16.12,80-36V84" fill="none" stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="16"/><line x1="64" y1="117" x2="64" y2="157" fill="none" stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="16"/><path d="M176,96.72c36.52,3.34,64,17.86,64,35.28,0,19.88-35.82,36-80,36-19.6,0-37.56-3.17-51.47-8.44" fill="none" stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="16"/><path d="M80,159.28V172c0,19.88,35.82,36,80,36s80-16.12,80-36V132" fill="none" stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="16"/><line x1="192" y1="165" x2="192" y2="205" fill="none" stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="16"/><line x1="128" y1="117" x2="128" y2="205" fill="none" stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="16"/></svg>}
    href="https://app.gitbutler.com/supporter"
    title="GitButler"
    description="Support GitButler with a monthly contribution"
  />
</Cards>

Thanks, from the GitButler Crew!

<img src="/img/pixel-bowtie.svg" className="" />



# but-base.mdx

## Usage

```
but base <SUBCOMMAND>
```

## Subcommands

### check

Fetches remotes from the remote and checks the mergeability of the branches in the workspace.

```
but base check
```

Shows the status of the base branch including:

- Base branch name
- Number of upstream commits
- Recent commits
- Status of active branches (updatable, integrated, conflicted, etc.)

### update

Updates the workspace (with all applied branches) to include the latest changes from the base branch.

```
but base update
```

Integrates upstream changes into your workspace branches, rebasing or deleting branches as appropriate.

## Examples

Check base branch status:

```
but base check
```

Update workspace with base branch changes:

```
but base update
```


# but-branch.mdx

## Usage

```
but branch <SUBCOMMAND>
```

## Subcommands

### new

Creates a new branch in the workspace.

```
but branch new [OPTIONS] [BRANCH_NAME]
```

#### Arguments

- `[BRANCH_NAME]` - Name of the new branch (optional, auto-generated if not provided)

#### Options

- `-a, --anchor <ANCHOR>` - Anchor point - either a commit ID or branch name to create the new branch from

### delete

Deletes a branch from the workspace.

```
but branch delete [OPTIONS] <BRANCH_NAME>
```

Alias: `-d`

#### Arguments

- `<BRANCH_NAME>` - Name of the branch to delete (required)

#### Options

- `-f, --force` - Force deletion without confirmation

### list

List the branches in the repository.

```
but branch list [OPTIONS]
```

#### Options

- `-l, --local` - Show only local branches

### unapply

Unapply a branch from the workspace.

```
but branch unapply [OPTIONS] <BRANCH_NAME>
```

#### Arguments

- `<BRANCH_NAME>` - Name of the branch to unapply (required)

#### Options

- `-f, --force` - Force unapply without confirmation

## Examples

Create a new branch with auto-generated name:

```
but branch new
```

Create a new branch with a specific name:

```
but branch new my-feature
```

Create a new branch from a specific commit:

```
but branch new my-feature --anchor abc123
```

Delete a branch with confirmation:

```
but branch delete my-feature
```

Force delete a branch without confirmation:

```
but branch delete my-feature --force
```

List all branches:

```
but branch list
```

List only local branches:

```
but branch list --local
```

Unapply a branch from the workspace:

```
but branch unapply my-feature
```


# but-commit.mdx

## Usage

```
but commit [OPTIONS]
```

## Options

### `-m, --message <MESSAGE>`

Commit message.

- **Type:** String
- **Required:** Optional

### `--branch <BRANCH>`

Branch CLI ID or name to derive the stack to commit to.

- **Type:** String
- **Required:** Optional

### `-o, --only`

Only commit assigned files, not unassigned files.

- **Type:** Flag (boolean)
- **Default:** `false`

## Examples

Commit with a message:

```
but commit -m "Add new feature"
```

Commit to a specific branch:

```
but commit -m "Fix bug" --branch my-feature-branch
```

Commit only assigned files:

```
but commit -m "Update docs" --only
```


# but-describe.mdx

## Usage

```
but describe <TARGET>
```

## Alias

This command can also be invoked using the shorter alias `desc`:

```
but desc <TARGET>
```

## Arguments

### `<TARGET>`

Commit ID to edit the message for, or branch ID to rename.

- **Type:** String
- **Required:** Yes

## Examples

Edit a commit message:

```
but describe abc123
```

Rename a branch:

```
but describe my-feature-branch
```


# but-forge.mdx

## Usage

```
but forge <SUBCOMMAND>
```

## Subcommands

### auth

Authenticate with your forge provider (at the moment, only GitHub is supported).

```
but forge auth
```

Initiates a device OAuth flow to authenticate with GitHub. You'll be provided with a code and URL to complete the authentication process.

### list-users

List authenticated forge accounts known to GitButler.

```
but forge list-users
```

Displays a list of all GitHub usernames that have been authenticated with GitButler.

### forget

Forget a previously authenticated forge account.

```
but forge forget <USERNAME>
```

#### Arguments

- `<USERNAME>` - The username of the forge account to forget (required)

## Examples

Authenticate with GitHub:

```
but forge auth
```

List authenticated users:

```
but forge list-users
```

Forget a GitHub account:

```
but forge forget octocat
```


# but-init.mdx

## Usage

```
but init [OPTIONS]
```

## Options

### `-r, --repo`

Also initializes a git repository in the current directory if one does not exist.

- **Type:** Flag (boolean)
- **Default:** `false`

## Examples

Initialize GitButler in an existing git repository:

```
but init
```

Initialize both git and GitButler:

```
but init --repo
```


# but-mark.mdx

## Usage

```
but mark [OPTIONS] <TARGET>
```

## Arguments

### `<TARGET>`

The target entity that will be marked.

- **Type:** String
- **Required:** Yes

## Options

### `-d, --delete`

Deletes a mark.

- **Type:** Flag (boolean)
- **Default:** `false`

## Examples

Create a mark:

```
but mark my-feature-branch
```

Delete a mark:

```
but mark my-feature-branch --delete
```

## Related Commands

- [`but unmark`](but-unmark) - Removes all marks from the workspace


# but-mcp.mdx

## Usage

```
but mcp [OPTIONS]
```

## Description

Starts the Model Context Protocol (MCP) server for GitButler, enabling integration with AI assistants and other tools that support the MCP protocol.

## Options

### `-i, --internal`

Starts the internal MCP server which has more granular tools.

- **Type:** Flag (boolean)
- **Default:** `false`
- **Note:** This option is hidden from standard help output

## Examples

Start the standard MCP server:

```
but mcp
```

Start the internal MCP server with more granular tools:

```
but mcp --internal
```


# but-new.mdx

## Usage

```
but new <TARGET>
```

## Arguments

### `<TARGET>`

Commit ID to insert before, or branch ID to insert at top of stack.

- **Type:** String
- **Required:** Yes

## Examples

Insert a blank commit before a specific commit:

```
but new abc123
```

Insert a blank commit at the top of a branch's stack:

```
but new my-feature-branch
```


# but-oplog.mdx

## Usage

```
but oplog [OPTIONS]
```

## Description

Displays the operation log (oplog) which tracks all operations performed in your GitButler workspace. This is useful for understanding what changes have been made and for potentially undoing or restoring to previous states.

## Options

### `--since <SHA>`

Start from this oplog SHA instead of the head.

- **Type:** String
- **Required:** Optional

## Examples

Show recent operation history:

```
but oplog
```

Show operation history from a specific point:

```
but oplog --since abc123def456
```

## Related Commands

- [`but undo`](but-undo) - Undo the last operation
- [`but restore`](but-restore) - Restore to a specific oplog snapshot
- [`but snapshot`](but-snapshot) - Create an on-demand snapshot


# but-publish.mdx

## Usage

```
but publish [OPTIONS]
```

## Description

By default, publishes reviews for all active branches in your workspace. You can optionally specify a single branch to publish.

## Options

### `-b, --branch <BRANCH>`

Publish reviews only for the specified branch.

- **Type:** String
- **Required:** Optional

### `-f, --with-force`

Force push even if it's not fast-forward.

- **Type:** Flag (boolean)
- **Default:** `true`

### `-s, --skip-force-push-protection`

Skip force push protection checks.

- **Type:** Flag (boolean)
- **Default:** `false`

### `-r, --run-hooks`

Run pre-push hooks.

- **Type:** Flag (boolean)
- **Default:** `true`

## Examples

Publish all active branches:

```
but publish
```

Publish a specific branch:

```
but publish --branch my-feature
```

Publish without running hooks:

```
but publish --run-hooks=false
```


# but-push.mdx

## Usage

```
but push [OPTIONS] <BRANCH_ID>
```

## Arguments

### `<BRANCH_ID>`

Branch name or CLI ID to push.

- **Type:** String
- **Required:** Yes

## Options

### `-f, --with-force`

Force push even if it's not fast-forward.

- **Type:** Flag (boolean)
- **Default:** `true`

### `-s, --skip-force-push-protection`

Skip force push protection checks.

- **Type:** Flag (boolean)
- **Default:** `false`

### `-r, --run-hooks`

Run pre-push hooks.

- **Type:** Flag (boolean)
- **Default:** `true`

## Gerrit Options

The following options are only available when Gerrit mode is enabled for your repository:

### `-w, --wip`

Mark change as work-in-progress (Gerrit). Mutually exclusive with `--ready`.

- **Type:** Flag (boolean)
- **Default:** `false`

### `-y, --ready`

Mark change as ready for review (Gerrit). This is the default state. Mutually exclusive with `--wip`.

- **Type:** Flag (boolean)
- **Default:** `false`

### `-a, --hashtag, --tag <TAG>`

Add hashtag(s) to change (Gerrit). Can be used multiple times.

- **Type:** String (repeatable)
- **Required:** Optional

### `-t, --topic <TOPIC>`

Add custom topic to change (Gerrit). At most one topic can be set. Mutually exclusive with `--topic-from-branch`.

- **Type:** String
- **Required:** Optional

### `--tb, --topic-from-branch`

Use branch name as topic (Gerrit). Mutually exclusive with `--topic`.

- **Type:** Flag (boolean)
- **Default:** `false`

### `-p, --private`

Mark change as private (Gerrit).

- **Type:** Flag (boolean)
- **Default:** `false`

## Examples

Push a branch:

```
but push my-feature-branch
```

Force push without running hooks:

```
but push my-feature-branch --with-force --run-hooks=false
```

Push with Gerrit flags (when Gerrit mode is enabled):

```
but push my-feature-branch --ready --hashtag bug-fix --hashtag security
```

## Notes

- Gerrit push flags (`--wip`, `--ready`, `--hashtag/--tag`, `--topic`, `--topic-from-branch`, `--private`) can only be used when gerrit_mode is enabled for the repository
- `--wip` and `--ready` are mutually exclusive. Ready is the default state.
- `--topic` and `--topic-from-branch` are mutually exclusive. At most one topic can be set.
- Multiple hashtags can be specified by using `--hashtag` (or `--tag`) multiple times.


# but-restore.mdx

## Usage

```
but restore [OPTIONS] <OPLOG_SHA>
```

## Arguments

### `<OPLOG_SHA>`

Oplog SHA to restore to.

- **Type:** String
- **Required:** Yes

## Options

### `-f, --force`

Skip confirmation prompt.

- **Type:** Flag (boolean)
- **Default:** `false`

## Examples

Restore to a specific snapshot (with confirmation):

```
but restore abc123def456
```

Restore without confirmation prompt:

```
but restore abc123def456 --force
```

## Related Commands

- [`but oplog`](but-oplog) - Show operation history
- [`but undo`](but-undo) - Undo the last operation
- [`but snapshot`](but-snapshot) - Create an on-demand snapshot


# but-rub.mdx

## Usage

```
but rub <SOURCE> <TARGET>
```

## Description

The `rub` command is a versatile operation that combines two entities together to perform various operations depending on the types of entities provided.

### Supported Operations

| Source | Target | Operation |
| ------ | ------ | --------- |
| File   | Commit | Amend     |
| Branch | Commit | Amend     |
| Commit | Commit | Squash    |
| File   | Branch | Assign    |
| Branch | Branch | Assign    |
| Commit | Branch | Move      |

## Arguments

### `<SOURCE>`

The source entity to combine.

- **Type:** String
- **Required:** Yes

### `<TARGET>`

The target entity to combine with the source.

- **Type:** String
- **Required:** Yes

## Examples

Amend a file to a commit:

```
but rub path/to/file.txt abc123
```

Squash two commits:

```
but rub abc123 def456
```

Assign a file to a branch:

```
but rub path/to/file.txt my-feature-branch
```

Move a commit to a different branch:

```
but rub abc123 my-other-branch
```


# but-snapshot.mdx

## Usage

```
but snapshot [OPTIONS]
```

## Description

Creates a snapshot of the current workspace state in the operation log. This is useful for creating manual checkpoints before making significant changes.

## Options

### `-m, --message <MESSAGE>`

Message to include with the snapshot.

- **Type:** String
- **Required:** Optional

## Examples

Create a snapshot without a message:

```
but snapshot
```

Create a snapshot with a descriptive message:

```
but snapshot -m "Before refactoring authentication module"
```

## Related Commands

- [`but oplog`](but-oplog) - Show operation history
- [`but undo`](but-undo) - Undo the last operation
- [`but restore`](but-restore) - Restore to a specific oplog snapshot


# but-status.mdx

## Usage

```
but status [OPTIONS]
```

## Alias

This command can also be invoked using the shorter alias `st`:

```
but st [OPTIONS]
```

## Example Output

```cli but-st-c43eb45a
but status
```

## Options

### `-f, --files`

Determines whether the committed files should be shown as well.

- **Type:** Flag (boolean)
- **Default:** `false`

### `-v, --verbose`

Show verbose output with commit author and timestamp.

- **Type:** Flag (boolean)
- **Default:** `false`

### `-r, --review`

Show the forge review information.

- **Type:** Flag (boolean)
- **Default:** `false`

## Examples

Show basic status:

```
but status
```

Show status with files:

```
but status --files
```

Show verbose status with review information:

```
but status -v -r
```


# but-undo.mdx

## Usage

```
but undo
```

## Description

Reverts the workspace to the state it was in before the last operation. This uses the operation log (oplog) to roll back changes.

## Options

This command takes no specific options.

## Examples

Undo the last operation:

```
but undo
```

## Related Commands

- [`but oplog`](but-oplog) - Show operation history
- [`but restore`](but-restore) - Restore to a specific oplog snapshot
- [`but snapshot`](but-snapshot) - Create an on-demand snapshot


# but-unmark.mdx

## Usage

```
but unmark
```

## Description

This command removes all auto-assign and auto-commit rules (marks) from the workspace.

## Options

This command takes no specific options.

## Examples

Remove all marks:

```
but unmark
```

## Related Commands

- [`but mark`](but-mark) - Creates or removes a rule for auto-assigning or auto-committing


# installation.mdx

How to install and setup the GitButler CLI.

## Installing the `but` CLI

Ok, first thing is first, let's get our `but` CLI installed. Currently there are two ways to do this.

### Via the Desktop Client

If you have the desktop client installed, you can go into your global settings and click on the "Install CLI" button in the "general" section.

<ImageSection
  className="mx-auto"
  src="https://gitbutler-docs-images-public.s3.us-east-1.amazonaws.com/install-but.png"
  width="800"
  height="600"
  subtitle="How to install the GitButler CLI"
/>

### Homebrew

If you're running on a Mac and use Homebrew, you can install GitButler via `brew install gitbutler` and it will install the CLI for you automatically.

## Setup

There isn't currently much setup you can do, but this will change in the near future, such as setting your name and email for commits or the editor to use for your commit messages.

The next step is to initialize an existing Git repository to use GitButler branching and tooling, which you can read about in the next section, the Tutorial.


# branching-and-commiting.mdx

Now that your project is setup and GitButler is installed and configured, you can start branching and committing.

## The Simple Flow

Let’s begin with a simple workflow, one that should be familiar to Git users. We will:

- Do some work
- Create a new branch
- Commit to that branch

### Status

Let’s begin by seeing what the status of the working directory is by running `but status`. This will tell you a little more than `git status`, it will list:

1. All files in your working directory that differ from your base branch (`origin/main`) the last time you updated it that aren’t assigned to a branch
2. A list of the active branches that you have and
   1. All assigned file changes in each branch
   2. All commits in each branch

So it's sort of like a combination of `git status` and a shortlog of what is on your branches that is not on `origin/master`.

It looks something like this:

{/* restore [f0f437258043] */}
{/* run but rub wu gemfile-fixes */}
{/* run but rub te feature-bookmarks */}

```cli [7a684a53c92c90c9, 418px]
but status
```

Here we can see three applied branches: `gemfile-fixes` stacked on `feature-bookmarks` and independent `sc-branch-26`. There are also three unassigned files.

### Create a Branch

Let’s look at a very simple case first. Let’s say we’ve just modified some files and don’t have a branch yet. Our status might look like this:

{/* restore [04d62f15beb4] */}

```cli [a86fb55ce4c726bf, 220px]
but status
```

Now let’s say that we want to put those unassigned file changes into a commit on a new branch called `user-bookmarks`.

To do this, you can use the `but branch new <branch-name>` command.

{/* run git branch -D user-bookmarks */}

```cli [a976f522d9d44420, 44px]
but branch new user-bookmarks
```

Now if you run `but status` you can see your new empty branch:

```cli [0af893c1f8c760bd, 286px]
but status
```

### Commit to a Branch

Now we can commit our unassigned changes to that branch. You can simply assign your changes to the branch first to commit later (we’ll cover that later in [Rubbing](https://www.notion.so/Rubbing-2545a4bfdeac80209d37cd4d629316cc?pvs=21)), but for now let’s keep it simple and just commit them directly using the `but commit` command.

```cli [0110c7907c1cf514, 44px]
but commit -m 'all the user bookmarks'
```

If you don’t specify the `-m` commit message, GitButler will try to open an editor with a tempfile where you can write a longer commit message. It will use the `$EDITOR` environment variable if it’s set, or the `core.editor` Git or GitButler config setting, or it will prompt you for a command to run if you’re in an interactive terminal.

Now our status looks like this, with all unassigned files in a new commit on our new branch:

```cli [6344d5831aee974f, 176px]
but status
```

## Stacked and Parallel Branches

Ok, that’s the simple case, pretty straightforward. However, GitButler can also do some pretty cool things that Git either cannot do or struggles with, namely having multiple active branches that you can work on in parallel, and managing stacked branches. That is, both multiple independent and dependent active branches.

### Parallel Branches

Parallel branches is very simple, you can create multiple simultaneously active branches that you can assign and commit changes to in your workspace.

To create a parallel branch, you simply create a new branch the same way we did before. Let’s say that we want to create a `liked-tweets` branch alongside our existing `user-bookmarks`. We simply run the same `but branch new` command again:

{/* run git branch -D liked-tweets */}
{/* run echo 'test' > app/controllers/likes_controller.rb */}
{/* run echo 'test' > app/models/like.rb */}

```cli [d3f1c48945fc9809, 44px]
but branch new liked-tweets
```

Now if we run `but status` we can see our previous branch and our new empty branch.

```cli [64010dd6e8529339, 286px]
but status
```

We can see our previous branch and the commit we made, our new empty branch and a couple of modified files. Now we can commit the unassigned changes to that branch with `but commit -m "liked tweets changes" liked-tweets`

```cli [706747fbcb1889b7, 44px]
but commit -m "liked tweets changes" liked-tweets
```

And now we have one commit in each lane.

```cli [3987f8d371e20e27, 264px]
but status
```

Here we specified the entire branch name as the commit target (as there is more than one), but you can also use the two character short code that is next to each one.

If you don’t specify a branch identifier and you have more than one active branch, then GitButler will prompt you for which branch you wish to commit the unassigned changes to.

We can also see which files were modified in each commit with the `--files` or `-f` option to `but status`:

```cli [c679f47525fe3aa6, 440px]
but status -f
```

### Stacked Branches

The other way you can create new branches is to make them stacked, that is, one depends on another one and has to be merged in that order.

To create a new stacked branch in GitButler, you can run `but branch new` with a target branch ID. If we go back in time and instead stack our `liked-tweets` branch, we can make it dependent on the `user-bookmarks` branch by providing it as a stacking "anchor" with `-a` option:

{/* run git branch -D liked-tweets-stacked */}
{/* restore [e32713a1f41c] */}

```cli [f78665426ff0c23f, 44px]
but branch new -a user-bookmarks liked-tweets-stacked
```

```cli [5fb2d0bcb941c804, 286px]
but status
```

Now we can commit to our stacked branch.

```cli [10aecd5f47e264a7, 44px]
but commit -m "liked tweets changes" liked-tweets-stacked
```

```cli [c9fb470a128dcff6, 242px]
but status
```

Now if you push to a forge, GitButler will set up the reviews (Pull Request or Merge Request) as a stacked request, where `user-bookmarks` has to be merged either before or with `liked-tweets` but they can be reviewed independently.

## Assigning and Committing Changes

The other way to commit to a branch is to explicitly assign changes to it. This is somewhat like running `git add` in Git, where you’re staging some changes for a future commit. However, unlike Git where you have to do this or override it with `-a` or something, the default in GitButler is to commit all changes by default and only leave out unassigned changes with the flag `-o` or `--only`.

### Assigning Changes

So, how do we assign changes to a specific branch and then only commit those changes?

Let’s look at an example `but status` with six modified files and two empty, parallel branches and assign and commit one file to each branch as a separate commit.

{/* restore [d5c7317b0fd4] */}

```cli [b0a042fa1f10b0a8, 352px]
but status
```

We will assign each file to a different branch and then see the result. We assign file changes to branches using the `but rub` command, which combines things. We'll go more into all that rubbing can do later.

You can either rub the file identifier that you see next to each file, or all or part of the file path. For example, in this case to identify the `app/models/bookmark.rb` file, you can do any of:

- `xw`
- `app/models/`
- `bookmark`
- `app/models/bookmark.rb`

In order to differentiate a shortcode from a path, a shortcode is exactly 2 characters and a path needs to be at least 3. This is the same pattern matching used for the branch ID too.

So lets rub the bookmark changes into the bookmarks branch:

```cli [2a8b35a5f3fdc773, 88px]
but rub xw,ie,rt user-bookmarks
```

Now let's rub the user changes into the `user-changes` branch:

```cli [41851621cd9071e1, 44px]
but rub ku user-changes
```

Now we have some file changes assigned to each branch and still some unassigned changes:

```cli [734c068c0c406e82, 352px]
but status
```

Now, if we want to create a commit in the `user-bookmarks` branch, we can either run `but commit nd` which will create a commit with the files assigned as well as both files that are unassigned, but _not_ the file assigned to the `user-changes` lane.

Or, we can make a commit with _only_ the assigned files in `user-bookmarks` by using the `-o` option to `but commit`.

```cli [21fa219c49d8f8fe, 44px]
but commit -o -m "liked tweets view" h4
```

Now if we look at our status we can see a commit on our branch instead of the assigned changes:

```cli [8aec10380a37afc0, 352px]
but status
```

Now let's commit all the rest of the changes (assigned and unassigned) to our other branch:

```cli [f20a0ef692d37799, 44px]
but commit -m 'bookmarks stuff' nd
```

```cli [1cb6d694f8882426, 264px]
but status
```

### Assigning Ranges

If you happen to have a large number of changes, you can also use ranges or lists for rubbing assignment. So for example, if we go back to this status:

{/* restore [6fdd8fb1d547] */}
{/* run but rub nd 00 */}

```cli [b0a042fa1f10b0a8, 352px]
but status
```

Then you can assign the first, third, and fifth file to a branch with:

```cli [bf6d997a5b35a132, 88px]
but rub nx,xw,rt user-bookmarks
```

```cli [0729d431d2061013, 352px]
but status
```


# editing-commits.mdx

While you can rub changes in and out of commits, you can also edit the commit
message of any commit in your workspace quite easily.

## Editing Commit Messages

You can edit commit messages with the `but describe` command. So if we have this status:

{/* restore [d69fffa7c6eb] */}

```cli [387e58cb9b4bbbce, 198px]
but status
```

Then you can edit the message of any commit by running `but describe <sha>`, which will open up your editor of choice with the existing commit message and when you exit the editor, replace that message in the commit and rebase everything above it.

The editor would look something like this:

```
add user changes

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# Changes in this commit:
#       modified:   app/models/user.rb
#       modified:   config/routes.rb
#
~
~
~
~
```

Pretty simple.

{/* TODO: Edit Mode */}


# initializing-a-repository.mdx

If you run any `but` command in a repository that has never been seen by GitButler before, it will automatically run the `but init` command, which will need to have you confirm the upstream base branch (`origin/main` for example).

You can also run `but init` manually to set that up first, or 
```
❯ but init
Initialized GitButler project from .
The default target is origin/main
```

If there is an `origin/HEAD` reference (servers will often set this as a target branch), GitButler will use this.

Otherwise, the `but init` command will try to guess a default base branch by looking for `origin/main` or `origin/master`, as these are very common. If it finds one of these, it will set it and move on. If it does not, it will ask you which remote branch it should use as it’s target base.

A base branch has to be set on every project GitButler operates on. This is important to tell what is or is not considered "integrated".

<Callout type="info">

Currently a base branch needs to be on a remote. Our workflow currently assumes you are pushing to a forge and merging after review on that branch to the target base. Support for local-only workflows is coming, but not current possible.

</Callout>


# operations-log.mdx

GitButler maintains a detailed log of all operations, making it easy to track what happened and undo changes when needed.

## Viewing the Operations Log

See all recent GitButler operations:

```cli [e9d6ef69b35f2728, 506px]
but oplog
```

## Undoing the last operation

Undo the last operation:

```cli [3019b8bf7d04ba45, 88px]
but undo
```

## Restoring to a previous point

```cli [bacd8a0236b5ed4a, 176px]
but restore -f 6fdd8fb1d547
```


# rubbing.mdx

# Rubbing

As we saw in the [Branching and Committing](branching-and-commiting) section, the `but rub` command can be used to assign changes to branch lanes.

However, it can be used to do _so much_ more. Rubbing is essentially combining two things. Since there are lots of _things_ in the tool, combining them together can do lots of different operations. Most of them should be fairly intuitive once you understand the concept.

Let’s take a look at what is possible with this very straightforward command.

# Unassigning Changes

We already showed how you can use `rub` to assign a file change or set of changes to a branch for later committing (rubbing a file and a branch), but what if you want to undo that? Move assignments to a different lane or revert them to being unassigned for later?

As you may have noticed in the `but status` output, there is a special identifier `00` which is always the “unassigned” ID. If you rub anything to `00` then it will move it to unassigned.

So given this status:

```cli [7a684a53c92c90c9, 418px]
but status
```

We can re-unassign the `README.new.md` file with `but rub np 00`. Or, we can re-assign that file to the `sc-branch-26` parallel branch with `but rub np q6`.

# Amending Commits

However, assignment is not all we can do with rubbing. We can also use it to move things to and from commits. A common example would be to amend a commit with new work.

Let’s say that we sent commits out for review and got feedback and instead of creating new commits to address the review, we wanted to actually fix up our commits to be better. This is somewhat complicated to do in Git (something something [fixup commit, autosquash](https://blog.gitbutler.com/git-autosquash), etc). However, with `rub` it’s incredibly simple. Just rub the new changes into the target commit rather than a branch.

Let’s say that we have a branch with some commits in it, we’ve made changes to two files and want to amend two different commits with the new changes.

```cli [7a684a53c92c90c9, 418px]
but status
```

If we want to update the first commit (`5d70b6f`) with the `like_button.rb` changes and the last commit (`9ed9612`) with the `liked_tweets.html.erb` changes, we can run the following two `rub` commands:

[rub command]

Notice that the SHAs have changed, but the commit identifiers have not. It has rewritten the commits to have the same messages but incorporated the changes you rubbed into those patches.

If you wanted to rub all the unassigned changes into a specific commit, you could also do that by rubbing the unassigned section to a commit, for example `but rub 00 1l` which would take all unassigned changes and amend commit `1l` with them.

# Squashing Commits

File changes are not the only thing that you can rub. You can also rub commits into things. To squash two commits together, you simply rub them together. Let’s take the last status output and squash the first commit into the third:

```
❯ but rub ux 1l

Squashed commits:
  - 8df823d ("Show recent active users on admin page")
into:
	- d78fe05 ("Add liked tweets section to the LikesController")
```

Now we can see that we only have two commits in our branch:

```
❯ but status

📍 Base: origin/main @ 83afc2a
🔺 You are 32 commits behind origin/main
    (Run `but base update` to rebase your stack)
****
╭ **8x** **[sc-liked-tweets]**
● **9r** 7a4ecf4 Add Liked Tweets page to dashboard
● **1l** 7de8f04 Add liked tweets section to the LikesController
╯

**00** **Unassigned Changes**
   (none)
```

If we look at `1l` now, it has combined the commit messages and associated changes into a single commit. It’s possible that this will introduce a merge conflict to the commit that was in the middle (_which won’t happen if you squash two neighboring commits, but in this case we used a slightly more complex skip-squash_), but you can always [undo it](https://www.notion.so/Operations-Log-2545a4bfdeac8087a518dcf7448f62d3?pvs=21) or [resolve the conflict](https://www.notion.so/Resolving-Conflicts-2545a4bfdeac80b7a587c2b9f23ca890?pvs=21).

You probably want to [edit the commit message](https://www.notion.so/Editing-Commits-2545a4bfdeac809b985ec774d1beb32f?pvs=21) after this too, since it will simply combine the two commit messages.

# Uncommitting

Let’s say that we want to just _undo_ a commit - that is, pretend that we had not made that commit and instead put the changes back to unassigned status. In this case we would use the special `00` ID that we talked about earlier, just like unassigning changes, we can unassign commits.

So, if we’re back to this status:

```
❯ but status

📍 Base: origin/main @ 83afc2a
🔺 You are 32 commits behind origin/main
    (Run `but base update` to rebase your stack)
****
╭ **8x** **[sc-liked-tweets]**
● **ux** 8df823d Show recent active users on admin page
● **9r** 937ace4 Add Liked Tweets page to dashboard
● **1l** d78fe05 Add liked tweets section to the LikesController
╯

**00** **Unassigned Changes**
   (none)
```

And we want to un-commit the first commit (`1l`) as though we had never made it, you can rub to `00`:

```
❯ but rub 1l 00

Uncommitted d78fe05 ("Add liked tweets section to the LikesController")

Newly unassigned changes:
**gt** M  app/views/dashboard/liked_tweets.html.erb
**6i** M  app/components/tweet/like_button.rb
```

Now if we look at our status again, we will see that commit removed and those files back in the unassigned status:

```
❯ but status

📍 Base: origin/main @ 83afc2a
🔺 You are 32 commits behind origin/main
    (Run `but base update` to rebase your stack)
****
╭ **8x** **[sc-liked-tweets]**
● **ux** 9ed9612 Show recent active users on admin page
● **9r** 1970ca4 Add Liked Tweets page to dashboard
╯

**00** **Unassigned Changes
gt** M  app/views/dashboard/liked_tweets.html.erb
**6i** M  app/components/tweet/like_button.rb
```

# Moving Commits

We can also use rubbing to move a commit from one branch to another branch if we have multiple active branches and committed to the wrong one, or otherwise decide that we want to split up independent work.

Let’s say that we have two commits on one branch and one commit on a second parallel branch and want to move one:

```
❯ but status

📍 Base: origin/main @ 83afc2a
🔺 You are 32 commits behind origin/main
    (Run `but base update` to rebase your stack)

****╭  **p3** **[liked-tweets]**
●  **2p** 2acf832 liked tweets view
╯
╭  **8x** **[cache-tester]**
●  **e8** f8f3e3a test tweeting functionality
●  **q9** a9cfef2 add cache tests
╯

**00** **Unassigned Changes**
   (none)
```

We can move the “tweeting tests” commit to the `liked-tweets` branch with `but rub`:

```
❯ but rub e8 p3

Moved commit f8f3e3a ("test tweeting functionality...")
	to: branch **liked-tweets**
```

Now we can see that the commit has been moved to the top of the new branch:

```
❯ but status

📍 Base: origin/main @ 83afc2a
🔺 You are 32 commits behind origin/main
    (Run `but base update` to rebase your stack)

****╭  **p3** **[liked-tweets]**
●  **e8** 8efdea6 test tweeting functionality
●  **2p** 2acf832 liked tweets view
╯
╭  **8x** **[cache-tester]**
●  **q9** a9cfef2 add cache tests
╯

**00** **Unassigned Changes**
   (none)
```

Notice that the only SHA that changed was the one that moved, since nothing else needed to be rebased. Rubbing a commit to another branch always adds it to the top of that branch. If you then want to move it lower in the branch, you can use the [`but move`](https://www.notion.so/move-2065a4bfdeac802a88cff5498b409ec2?pvs=21) command.

As you might imagine, you can also simultaneously move and squash by rubbing a commit in one branch on a commit in another branch too.

# Moving Files and Hunks between Commits

You can also move files, hunks, or lines from one commit to another, or from unassigned to a commit, much like you can move stuff from unassigned to a lane via “[Partial Assigning](https://www.notion.so/Branching-and-Committing-2545a4bfdeac80c5a48ffb6cf219181c?pvs=21)” (ranges and whatnot).

To do that, you need identifiers for the files and hunks in an existing commit, which you can get via a `but status -f`, or `but status --files` that tells status to also list commit file IDs.

```
❯ but status -f

📍 Base: origin/main @ 83afc2a
🔺 You are 32 commits behind origin/main
    (Run `but base update` to rebase your stack)

****╭  **p3** **[liked-tweets]**
●  **e8** 8efdea6 **test tweeting functionality**
│  **6i** M  app/components/tweet/like_button.rb
│  **gt** M  app/views/dashboard/liked_tweets.html.erb
│
●  **2p** 2acf832 **liked tweets view**
│  **i4** M  app/controllers/tweet_controller.rb
╯
╭  **8x** **[cache-tester]**
●  **q9** a9cfef2 **add cache tests**
│  **6q** A  tests/scripts/cache_tester.t
│  **dx** A  scripts/debug/cache_tester.sh
╯

**00** **Unassigned Changes**
   (none)
```

So now we can move the changes from one commit to another by rubbing pretty easily. Let’s take the `liked_tweets.html.erb` change and move it down to the “liked tweets view” commit:

```
❯ but rub gt 2p

Moved to commit 2acf832 ("liked tweets view..."):
  - M  app/views/dashboard/liked_tweets.html.erb
```

Now the change is in the previous commit:

```
❯ but status -f

📍 Base: origin/main @ 83afc2a
🔺 You are 32 commits behind origin/main
    (Run `but base update` to rebase your stack)

****╭  **p3** **[liked-tweets]**
●  **e8** ed3fde4 **test tweeting functionality**
│  **6i** M  app/components/tweet/like_button.rb
│
●  **2p** c4def87 **liked tweets view**
│  **i4** M  app/controllers/tweet_controller.rb
│  **gt** M  app/views/dashboard/liked_tweets.html.erb
╯
╭  **8x** **[cache-tester]**
●  **q9** a9cfef2 **add cache tests**
│  **6q** A  tests/scripts/cache_tester.t
│  **dx** A  scripts/debug/cache_tester.sh
╯

**00** **Unassigned Changes**
   (none)
```

Even hunks within files are movable, the same way that we saw in the “[Partial Assigning](https://www.notion.so/Branching-and-Committing-2545a4bfdeac80c5a48ffb6cf219181c?pvs=21)” section:

```
❯ but rub gt:3-5 2p

Moved to commit 2acf832 ("liked tweets view..."):
  - M  app/views/dashboard/liked_tweets.html.erb (3-5)
```

Now parts of the change to that file are in two different commits:

```
❯ but status -f

📍 Base: origin/main @ 83afc2a
🔺 You are 32 commits behind origin/main
    (Run `but base update` to rebase your stack)

****╭  **p3** **[liked-tweets]**
●  **e8** ed3fde4 **test tweeting functionality**
│  **6i** M  app/components/tweet/like_button.rb
│  **gt** M  app/views/dashboard/liked_tweets.html.erb (1-2, 6-9)
│
●  **2p** c4def87 **liked tweets view**
│  **i4** M  app/controllers/tweet_controller.rb
│  **gt** M  app/views/dashboard/liked_tweets.html.erb (3-5)
╯
╭  **8x** **[cache-tester]**
●  **q9** a9cfef2 **add cache tests**
│  **6q** A  tests/scripts/cache_tester.t
│  **dx** A  scripts/debug/cache_tester.sh
╯

**00** **Unassigned Changes**
   (none)
```

# Splitting Commits

Ok, so now we can be pretty specifc about moving changes around to all these different states. The last thing we’ll cover here is splitting commits, which requires a new command that creates a new empty commit called `but new`.

By default, `but new` will create a new empty commit at the top of the most recently created branch, however you can specify a different branch, or even a specific place within a branch with existing commits.

Let’s say that we’re back to this state:

```
❯ but status

📍 Base: origin/main @ 83afc2a
🔺 You are 32 commits behind origin/main
    (Run `but base update` to rebase your stack)

****╭  **p3** **[liked-tweets]**
●  **e8** 8efdea6 test tweeting functionality
●  **2p** 2acf832 liked tweets view
╯
╭  **8x** **[cache-tester]**
●  **q9** a9cfef2 add cache tests
╯

**00** **Unassigned Changes**
   (none)
```

Now we want to split the “liked tweets view” back into two separate commits. The way we do this is to insert a blank commit in between `e8` and `2p` and then rub changes into it (then probably edit the commit message).

We can insert a blank commit by running `but new p3` which inserts a blank commit at the top of that branch. Or, we could also say `but new e8`, specifying the first commit on that branch and it will insert one above that. Or we could say `but new 2p` which would insert a blank in between the two commits on that branch. Or, we could insert one at the base of the branch by putting one below `2p` with `but new -b 2p` (short for `--below`). Let’s do the simple version of just adding it to the top of the branch:

```
❯ but new p3

Created new blank commit above:
  - 8efdea6 test tweeting functionality
```

Now we have a blank commit:

```
❯ but status

📍 Base: origin/main @ 83afc2a
🔺 You are 32 commits behind origin/main
    (Run `but base update` to rebase your stack)

****╭  **p3** **[liked-tweets]**
●  **6w** f4f96e3 (blank)
****●  **e8** 8efdea6 test tweeting functionality
●  **2p** 2acf832 liked tweets view
╯
╭  **8x** **[cache-tester]**
●  **q9** a9cfef2 add cache tests
╯

**00** **Unassigned Changes**
   (none)
```

Now we can use the previous method of moving file changes from other commits into it, then edit the commit message with `but describe 6w` (for more on the `describe` command, see [Editing Commits](https://www.notion.so/Editing-Commits-2545a4bfdeac809b985ec774d1beb32f?pvs=21), coming up next).


# scripting.mdx

## JSON Mode

```cli [57c76ba368268a45, 16522px]
but -j status
```


# tutorial-overview.mdx

https://www.youtube.com/watch?v=loavN_hHuEs

Using the GitButler CLI is meant to make a specific common workflow very simple, which is roughly:

- Create a branch
- Do work on that branch
- Commit to that branch
- Optionally, create another branch if you find unrelated work you need to do
- Work on and commit to that branch
- Submit a branch for review
- Create a stacked branch if needed to continue on dependent work
- Update your base if work has been integrated to remove merged work
- Rinse and repeat

Additionally, GitButler is very good at editing commits (amending fixup work, squashing, rewording messages, etc), it keeps a simple log of what you've done in case you need to go back in time, it makes collaborating on a branch with others easy, it has great GitHub/Lab integration and more.

Let's walk through some of the things it can do and what a typical day using the GitButler CLI might look like.


# updating-the-base.mdx

The base branch is the foundation that your feature branches build upon. Keeping it updated and managing it properly is crucial for a smooth workflow.

## Understanding the Base Branch

The base branch is typically your main development branch (`main`, `master`, or `develop`). All your feature branches are conceptually built on top of this base.

## Viewing Upstream

What is upstream

## Updating the Base from Remote

Keep your base branch updated with the remote repository:

## Changing the Base Branch

You can change which branch serves as your base:


# open-source.mdx

GitButler is a [Fair Source software project](https://blog.gitbutler.com/gitbutler-is-now-fair-source/), built on a vast foundation of open source software. We're committed to giving back to the community and supporting the projects that we rely on.

As part of our commitment to open source, we are an early member of the [Open Source Pledge](https://osspledge.com/). We have pledged to give back to the open source community by donating $2000 per year per full time software developer that we employ to the OSS projects and maintainers that we depend on.

You can read more about our reasoning to join the Open Source Pledge in our announcement blog post and 2024 report: [GitButler Joins the Open Source Pledge](https://blog.gitbutler.com/open-source-pledge-2024).


# integration-branch.mdx


Bundling all your virtual branches together

Since GitButler does some pretty fun stuff with branches in order to enable virtual branches to work, some Git commands run from other git clients, including stock Git in the terminal are bound to behave a little strangely.

We're getting the git data to think in three dimensions, then asking 2-D Git how to deal with it.

While some commands cannot work well because of this single-branch limitation (commit, checkout), we do try our best to keep everything in a state where most other commands work reasonably well. Anything having to do with the index or HEAD is a little problematic, but doable in a smooshed state (all branches look like one), while commands like `log` or `blame` work totally fine with no shenanigans.

## The Integration Commit
The way that we handle this relatively well is by creating an "integration" commit every time you change the committed state of your collective virtual branches.

<ImageSection
  alt="Viewing Remote Branches"
  src="/integration-01.png"
  subtitle="An 'integration' commit example."
/>


So what is an "integration" commit? Well, when you apply or unapply branches, or you commit on one of your applied branches, you change the state of what GitButler sees as your overall committed state with regards to your working directory.

## Status, Diff and Log

To keep Git command output for things that look at the index and HEAD (such as `status` or `diff`) somewhat sane, we modify your index to look like the union of all the committed states of all your applied virtual branches. This makes `git diff` and `git status` behave more or less like you would expect.

For instance, if you have two files on Branch A and two files on Branch B, then `git status` will simply list four files as modified.

However, to help out, we also write out a branch with a custom commit message that tries to explain the state of things and what is happening. This is written to a branch we own called `gitbutler/workspace` and you shouldn't touch it.

If you run `git log`, the first commit should be our custom commit message and the tree of that commit is the union of all the committed work on all your applied virtual branches, as though they were all merged together into one (something stock Git can understand).

## Committing, Branching, Checking Out

However, if you try to use something that writes to HEAD, like `git commit` or `git checkout`, then you might have some headaches. By default, our client will simply overwrite the `gitbutler/workspace` branch commit whenever something significant changes.

We won't touch the working directory in an unexpected way, so whatever you commit won't be lost, but the commit itself will be forgotten. Don't do branch stuff in stock Git while trying to use GitButler for now. We have ideas on how to make this somewhat doable in the future, but right now it's easier on everyone to stick with one or the other.

## Git Add and the Index

If you attempt to modify the index directly (running `git add` or `git rm`), GitButler won't notice or care. It will simply overwrite it with whatever it needs during its operations, so while I wouldn't do it, there is also not a lot of danger.

The worst that would happen is that you do some complex `git add -i` patch staging and then we wipe it out by rewriting the index. But again, you shouldn't be using stock Git commands related to committing or branching. You gotta choose one or the other for now, you can't go back and forth super easily.

## Recovering or Stopping GitButler Usage

If you want to stop using GitButler and go back to using stock Git commands for committing and branching, simply check out another branch. GitButler will realize that you've changed its branch and stop functioning until you reset it.

To help with remembering where you were, the integration commit should have the branch name and commit SHA that you were on when GitButler was initially activated. You should be able to easily go back to that branch and its last known commit state.
